// Generated by CoffeeScript 1.9.2
(function(ªG) {
/*! Proon 0.0.6 //// MIT Licence //// http://proon.richplastow.com/ */
var Proon, SomeClass, Tudor, objectSerializer, storageSerializer, tudor, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªinsert, ªis, ªisU, ªredefine, ªtype, ªuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ªC = 'Proon';

ªV = '0.0.6';

SomeClass = (function() {
  SomeClass.prototype.C = 'SomeClass';

  SomeClass.prototype.toString = function() {
    return '[object SomeClass]';
  };

  function SomeClass(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass()\n  ";
    this.x = null;
  }

  SomeClass.prototype.xx = function(yy) {
    var M;
    return M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass:xx()\n  ";
  };

  return SomeClass;

})();

SomeClass.xx = function(yy) {
  var M;
  return M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass.xx()\n  ";
};

Proon = (function() {
  Proon.prototype.C = 'Proon';

  Proon.prototype.toString = function() {
    return '[object Proon]';
  };

  function Proon(config) {
    var M, ts;
    if (config == null) {
      config = {};
    }
    M = "/proon/src/Proon.litcoffee Proon()\n  ";
    if (ªU === typeof config.object) {
      this.object = null;
    } else if (ªO !== ªtype(config.object)) {
      throw TypeError(M + "Optional `config.object` is " + (ªtype(config.object)) + " not object");
    } else {
      this.object = config.object;
    }
    ts = ªtype(config.storage);
    if (ªU === ts) {
      this.storage = null;
    } else if (ªO !== ts && 'storage' !== ts) {
      throw TypeError(M + "Optional `config.storage` is " + ts + " not object or storage");
    } else if (ªF !== typeof config.storage.setItem) {
      throw TypeError(M + "Optional `config.storage` has no `setItem()` method");
    } else {
      this.storage = config.storage;
    }
    if (ªU === typeof config.fs) {
      this.fs = null;
    } else if (ªO !== ªtype(config.fs)) {
      throw TypeError(M + "Optional `config.fs` is " + (ªtype(config.fs)) + " not object");
    } else if (ªF !== typeof config.fs.readFileSync) {
      throw TypeError(M + "Optional `config.fs` has no `readFileSync()` method");
    } else {
      this.fs = config.fs;
    }
    if (ªU === typeof config.db) {
      this.db = null;
    } else if (ªO !== ªtype(config.db)) {
      throw TypeError(M + "Optional `config.db` is " + (ªtype(config.db)) + " not object");
    } else {
      this.db = config.db;
    }
    if (ªU === typeof config.dom) {
      this.dom = null;
    } else if (ªO !== ªtype(config.dom)) {
      throw TypeError(M + "Optional `config.dom` is " + (ªtype(config.dom)) + " not object");
    } else {
      this.dom = config.dom;
    }
  }

  Proon.prototype.add = function(node) {
    var M, content, curr, i, j, key, len, len1, len2, len3, len4, m, maxLen, maxLevels, name, nameRx, o, path, pathRx, q, r, str, value;
    M = "/proon/src/Proon.litcoffee Proon:add()\n  ";
    if (ªO !== ªtype(node)) {
      throw TypeError(M + "`node` is " + (ªtype(node)) + " not object");
    }
    name = node.name;
    path = node.path;
    content = node.content;
    nameRx = /^[a-z][-a-z0-9]{0,23}$/;
    if (ªS !== typeof name) {
      throw TypeError(M + "`node.name` is " + (ªtype(name)) + " not string");
    }
    if (!nameRx.test(name)) {
      throw RangeError(M + "`node.name` fails " + nameRx);
    }
    pathRx = /^[a-z][-a-z0-9]{0,23}$/;
    maxLevels = 99;
    if (ªU === typeof path) {
      path = [];
    } else if (ªA !== ªtype(path)) {
      throw TypeError(M + "`node.path` is " + (ªtype(path)) + " not array");
    } else if (maxLevels < path.length) {
      throw RangeError(M + "`node.path.length` " + path.length + " > " + maxLevels);
    }
    for (i = j = 0, len = path.length; j < len; i = ++j) {
      str = path[i];
      if (ªS !== typeof str) {
        throw TypeError(M + "`node.path[" + i + "]` is " + (ªtype(path[i])) + " not string");
      }
      if (!pathRx.test(str)) {
        throw RangeError(M + "`node.path[" + i + "]` fails " + pathRx);
      }
    }
    maxLen = 1024 * 1024;
    if (ªU === typeof content) {
      content = '';
    } else if (ªS !== typeof content) {
      throw TypeError(M + "`node.content` is " + (ªtype(content)) + " not string");
    } else if (maxLen < content.length) {
      throw TypeError(M + "`node.content.length` " + content.length + " > " + maxLen);
    }
    if (this.object) {
      curr = this.object;
      for (i = m = 0, len1 = path.length; m < len1; i = ++m) {
        str = path[i];
        curr = curr[str];
        if (ªS === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is already an object leaf-node");
        }
        if (ªU === typeof curr) {
          break;
        }
      }
      if (curr) {
        if (ªS === typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is already an object leaf-node");
        }
        if (ªU !== typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is already an object branch-node");
        }
      }
    }
    if (this.storage) {
      key = '/';
      value = true;
      for (i = o = 0, len2 = path.length; o < len2; i = ++o) {
        str = path[i];
        value = this.storage.getItem(key += str);
        if (null === value) {
          break;
        }
        if ('/' !== value) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is already a storage leaf-node");
        }
        key += '/';
      }
      if (value) {
        value = this.storage.getItem(key += name);
        if ('/' === value) {
          throw RangeError(M + "`node.name` '" + name + "' is already a storage branch-node");
        }
        if (null !== value) {
          throw RangeError(M + "`node.name` '" + name + "' is already a storage leaf-node");
        }
      }
    }
    if (this.fs) {
      123;
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    if (this.object) {
      curr = this.object;
      for (i = q = 0, len3 = path.length; q < len3; i = ++q) {
        str = path[i];
        if (ªU === typeof curr[str]) {
          curr[str] = {
            __: curr
          };
        }
        curr = curr[str];
      }
      curr[name] = content;
    }
    if (this.storage) {
      key = '/';
      for (i = r = 0, len4 = path.length; r < len4; i = ++r) {
        str = path[i];
        if (null === this.storage.getItem(key = "" + key + str)) {
          this.storage.setItem(key, '/');
        }
        key += '/';
      }
      key = "" + key + name;
      this.storage.setItem(key, '-' + content);
    }
    if (this.fs) {
      123;
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    return this;
  };

  Proon.prototype["delete"] = function(node) {
    var M, curr, i, j, k, key, l, len, len1, len2, len3, len4, m, maxLevels, name, nameRx, o, path, pathRx, q, r, ref, ref1, str, subs, u, v, value;
    M = "/proon/src/Proon.litcoffee Proon:delete()\n  ";
    if (ªO !== ªtype(node)) {
      throw TypeError(M + "`node` is " + (ªtype(node)) + " not object");
    }
    name = node.name;
    path = node.path;
    nameRx = /^[a-z][-a-z0-9]{0,23}$/;
    if (ªU === typeof name) {
      name = false;
    } else if (ªS !== typeof name) {
      throw TypeError(M + "`node.name` is " + (ªtype(name)) + " not string");
    } else if (!nameRx.test(name)) {
      throw RangeError(M + "`node.name` fails " + nameRx);
    }
    pathRx = /^[a-z][-a-z0-9]{0,23}$/;
    maxLevels = 99;
    if (ªU === typeof path) {
      path = [];
    } else if (ªA !== ªtype(path)) {
      throw TypeError(M + "`node.path` is " + (ªtype(path)) + " not array");
    } else if (maxLevels < path.length) {
      throw RangeError(M + "`node.path.length` " + path.length + " > " + maxLevels);
    }
    for (i = j = 0, len = path.length; j < len; i = ++j) {
      str = path[i];
      if (ªS !== typeof str) {
        throw TypeError(M + "`node.path[" + i + "]` is " + (ªtype(path[i])) + " not string");
      }
      if (!pathRx.test(str)) {
        throw RangeError(M + "`node.path[" + i + "]` fails " + pathRx);
      }
    }
    if (this.object) {
      curr = this.object;
      for (i = m = 0, len1 = path.length; m < len1; i = ++m) {
        str = path[i];
        curr = curr[str];
        if (ªU === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is undefined in the object");
        }
        if (ªS === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is an object leaf- not branch-node");
        }
      }
      if (name) {
        if (ªU === typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is undefined in the object");
        }
        if (ªS !== typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is an object branch- not leaf-node");
        }
      }
    }
    if (this.storage) {
      key = '/';
      for (i = o = 0, len2 = path.length; o < len2; i = ++o) {
        str = path[i];
        value = this.storage.getItem(key += str);
        if (null === value) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is undefined in storage");
        }
        if ('/' !== value) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is a storage leaf- not branch-node");
        }
        key += '/';
      }
      if (name) {
        value = this.storage.getItem(key + name);
        if (null === value) {
          throw RangeError(M + "`node.name` '" + name + "' is undefined in storage");
        }
        if ('/' === value) {
          throw RangeError(M + "`node.name` '" + name + "' is a storage branch- not leaf-node");
        }
      }
    }
    if (this.fs) {
      123;
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    if (this.object) {
      curr = this.object;
      for (i = q = 0, len3 = path.length; q < len3; i = ++q) {
        str = path[i];
        curr = curr[str];
      }
      if (name) {
        delete curr[name];
      } else if (0 === path.length) {
        this.object = {};
      } else if (str = path[--i]) {
        curr = curr.__;
        delete curr[str];
      }
      while (str = path[--i]) {
        curr = curr.__;
        if (1 === Object.keys(curr[str]).length) {
          delete curr[str];
        }
      }
    }
    if (this.storage) {
      key = path.length ? '/' + path.join('/') : '';
      if (name) {
        this.storage.removeItem(key + '/' + name);
      } else if (0 === path.length) {
        this.storage.clear();
      } else {
        this.storage.removeItem(key);
        l = key.length;
        subs = [];
        for (i = r = 0, ref = this.storage.length - 1; 0 <= ref ? r <= ref : r >= ref; i = 0 <= ref ? ++r : --r) {
          if ((k = this.storage.key(i)) && k.substr(0, l) === key) {
            subs.push(k);
          }
        }
        for (u = 0, len4 = subs.length; u < len4; u++) {
          k = subs[u];
          this.storage.removeItem(k);
        }
      }
      outer: //;
      while (key) {
        l = key.length;
        for (i = v = 0, ref1 = this.storage.length - 1; 0 <= ref1 ? v <= ref1 : v >= ref1; i = 0 <= ref1 ? ++v : --v) {
          if ((k = this.storage.key(i)) !== key && k.substr(0, l) === key) {
            break outer;
          }
        }
        this.storage.removeItem(key);
        key = key.replace(/\/[^\/]+$/, '');
      }
    }
    return this;
  };

  return Proon;

})();

Proon.xx = function(yy) {
  var M;
  return M = "/proon/src/Proon.litcoffee Proon.xx()\n  ";
};

ªA = 'array';

ªB = 'boolean';

ªE = 'error';

ªF = 'function';

ªN = 'number';

ªO = 'object';

ªR = 'regexp';

ªS = 'string';

ªU = 'undefined';

ªX = 'null';

ª = console.log.bind(console);

ªex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

ªis = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

ªhas = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

ªtype = function(x) {
  return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

ªisU = function(x) {
  return ªU === typeof x;
};

ªuid = function(p) {
  return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
};

ªinsert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

ªredefine = function(obj, name, value, kind) {
  switch (kind) {
    case 'constant':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: true
      });
    case 'private':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: false
      });
  }
};

if (ªF === typeof define && define.amd) {
  define(function() {
    return Proon;
  });
} else if (ªO === typeof module && module && module.exports) {
  module.exports = Proon;
} else {
  ªG.Proon = Proon;
}

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (ªA !== ªtype(lines)) {
      throw new Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw new Error("`lines` has no elements");
    }
    if (ªS !== ªtype(lines[0])) {
      throw new Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (ªtype(line)) {
        case ªO:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case ªF:
          section.jobs.push(line);
          break;
        case ªS:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, len, len1, len2, m, mock, mockFail, o, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = null;
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        section = ref1[m];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (o = 0, len2 = ref2.length; o < len2; o++) {
          job = ref2[o];
          switch (ªtype(job)) {
            case ªF:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case ªA:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== ªtype(result)) {
        return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (ªF !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (ªF !== ªtype(line2)) {
      return false;
    }
    if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: ªO === typeof window ? 'html' : 'plain'
});

Proon.runTest = tudor["do"];

objectSerializer = function(object) {
  var out;
  out = JSON.stringify(object, function(key, value) {
    if ('__' === key) {
      return '^';
    }
    return value;
  });
  return out.replace(/"__":"\^",/g, '');
};

storageSerializer = function(s) {
  var i, j, out, ref;
  if (0 === s.length) {
    return '[EMPTY]';
  }
  out = [];
  for (i = j = 0, ref = s.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    out.push(s.key(i) + ' ' + s.getItem([s.key(i)]));
  }
  return out.sort().join('\n');
};

tudor.add([
  "01 Proon Constructor", tudor.is, "The class and instance are expected types", "The Proon class is a function", ªF, function() {
    return Proon;
  }, "`new` returns an object", ªO, function() {
    return new Proon;
  }, "`config.object` exceptions", tudor["throw"], "If set, `config.object` must not be an array", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.object` is array not object", function() {
    return new Proon({
      object: []
    });
  }, "If set, `config.object` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.object` is null not object", function() {
    return new Proon({
      object: null
    });
  }, "`config.storage` exceptions", tudor["throw"], "If set, `config.storage` must not be a Date instance", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` is date not object or storage", function() {
    return new Proon({
      storage: new Date
    });
  }, "If set, `config.storage` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` is null not object or storage", function() {
    return new Proon({
      storage: null
    });
  }, "If `config.storage` is set, `config.storage.setItem` must be defined", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` has no `setItem()` method", function() {
    return new Proon({
      storage: {}
    });
  }, "If set, `config.storage` must have a `setItem()` method", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` has no `setItem()` method", function() {
    return new Proon({
      storage: {
        setItem: 123
      }
    });
  }, "`config.fs` exceptions", "If set, `config.fs` must not be an array", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` is array not object", function() {
    return new Proon({
      fs: []
    });
  }, "If set, `config.fs` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` is null not object", function() {
    return new Proon({
      fs: null
    });
  }, "If `config.fs` is set, `config.fs.readFileSync` must be defined", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` has no `readFileSync()` method", function() {
    return new Proon({
      fs: {}
    });
  }, "If set, `config.fs` must have a `readFileSync()` method", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` has no `readFileSync()` method", function() {
    return new Proon({
      fs: {
        readFileSync: 123
      }
    });
  }, "`config.db` exceptions", "If set, `config.db` must not be the Math object", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.db` is math not object", function() {
    return new Proon({
      db: Math
    });
  }, "`config.dom` exceptions", "If set, `config.dom` must not be a regexp", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.dom` is regexp not object", function() {
    return new Proon({
      dom: /abc/
    });
  }
]);

tudor.add([
  "02-1 Proon `add()` object", tudor.is, "The method is the expected type", function() {
    return [
      new Proon({
        object: {}
      })
    ];
  }, "`proon.add()` is a function", ªF, function(proon) {
    return proon.add;
  }, "`proon.add()` returns an object", ªO, function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "`proon.add()` object exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:add()\n  `node` is undefined not object", function(proon) {
    return proon.add();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node` is array not object", function(proon) {
    return proon.add([]);
  }, "`node.name` is not optional", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` is undefined not string", function(proon) {
    return proon.add({});
  }, "`node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` is array not string", function(proon) {
    return proon.add({
      name: []
    });
  }, "`node.name` must not begin with a hyphen", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: '-foo'
    });
  }, "`node.name` must not begin with a digit", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: '3foo'
    });
  }, "`node.name` must not contain capital letters", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: 'fOo'
    });
  }, "`node.name` must not contain a dot", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: 'fo.o'
    });
  }, "`node.name` must not already be a branch-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'a' is already an object branch-node", function(proon) {
    return proon.add({
      name: 'a'
    });
  }, "`node.name` must not already be a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'c' is already an object leaf-node", function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path` is string not array", function(proon) {
    return proon.add({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path.length` 100 > 99", function(proon) {
    return proon.add({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain numbers", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is number not string", function(proon) {
    return proon.add({
      path: ['abc', 123, 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '*'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd*ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not overwrite a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[2]` 'c' is already an object leaf-node", function(proon) {
    return proon.add({
      name: 'd',
      path: ['a', 'b', 'c']
    });
  }, "If set, `node.content` must not be a number", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content` is number not string", function(proon) {
    return proon.add({
      name: 'foo',
      content: 123
    });
  }, "If set, `node.content.length` must 1024 * 1024 or less", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content.length` 1049599 > 1048576", function(proon) {
    return proon.add({
      name: 'foo',
      content: Array(1024 * 1025).join('x')
    });
  }, "`proon.add()` object usage", tudor.equal, "`proon.object` stringifies as expected", '{"a":{"b":{"c":""}}}', function(proon) {
    return objectSerializer(proon.object);
  }
]);

tudor.add([
  "02-2 Proon `add()` storage", tudor.is, "(Set up a Proon instance with sessionStorage)", function() {
    var s;
    if (typeof window !== "undefined" && window !== null ? window.sessionStorage : void 0) {
      s = window.sessionStorage;
      s.clear();
    } else {
      s = {
        setItem: function(key, value) {
          this[key] = value;
          this.length++;
          return this.keys.push(key);
        },
        getItem: function(key) {
          return this[key] || null;
        },
        removeItem: function(key) {
          var i;
          i = this.keys.indexOf(key);
          if (-1 === i) {
            return;
          }
          this.keys.splice(i, 1);
          this.length--;
          return delete this[key];
        },
        clear: function() {
          var j, key, len, ref;
          ref = this.keys;
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            delete this[key];
          }
          this.length = 0;
          return this.keys = [];
        },
        key: function(i) {
          return this.keys[i];
        },
        length: 0,
        keys: []
      };
    }
    return [
      new Proon({
        storage: s
      })
    ];
  }, "`proon.add()` records to storage without error", ªO, function(proon) {
    var result;
    return result = proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "`proon.add()` storage exceptions", tudor["throw"], "`node.name` must not already be a branch-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'a' is already a storage branch-node", function(proon) {
    return proon.add({
      name: 'a'
    });
  }, "`node.name` must not already be a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'c' is already a storage leaf-node", function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not overwrite a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[2]` 'c' is already a storage leaf-node", function(proon) {
    return proon.add({
      name: 'd',
      path: ['a', 'b', 'c']
    });
  }, "If set, `node.content` must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content` is array not string", function(proon) {
    return proon.add({
      name: 'foo',
      content: ['abc']
    });
  }, "`proon.add()` storage usage", tudor.equal, "`proon.storage` contains the expected key/value pairs", "/a /\n/a/b /\n/a/b/c -", function(proon) {
    return storageSerializer(proon.storage);
  }
]);

tudor.add([
  "03-1 Proon `delete()` object", tudor.is, "The method is the expected type", function() {
    return [
      new Proon({
        object: {}
      })
    ];
  }, "`proon.delete()` is a function", ªF, function(proon) {
    return proon["delete"];
  }, "`proon.delete()` returns an object", ªO, function(proon) {
    proon.add({
      name: 'a'
    });
    return proon["delete"]({
      name: 'a'
    });
  }, "`proon.delete()` object usage", tudor.equal, "`proon.object` is empty after the previous test", '{}', function(proon) {
    return objectSerializer(proon.object);
  }, "Add a top-level leaf-node, `proon.add({ name:'a', content:'ok' })`", '{"a":"ok"}', function(proon) {
    proon.add({
      name: 'a',
      content: 'ok'
    });
    return objectSerializer(proon.object);
  }, "Delete the top-level leaf-node, `proon.delete({ name:'a' })`", '{}', function(proon) {
    proon["delete"]({
      name: 'a'
    });
    return objectSerializer(proon.object);
  }, "Add two second-level leaf-nodes", '{"a":{"b":"one","c":"two"}}', function(proon) {
    proon.add({
      path: ['a'],
      name: 'b',
      content: 'one'
    }).add({
      path: ['a'],
      name: 'c',
      content: 'two'
    });
    return objectSerializer(proon.object);
  }, "Delete the first second-level leaf-node", '{"a":{"c":"two"}}', function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'b'
    });
    return objectSerializer(proon.object);
  }, "Delete the second second-level leaf-node", '{}', function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'c'
    });
    return objectSerializer(proon.object);
  }, "Add a fifth-level leaf-node", '{"a":{"b":{"c":{"d":{"e":{"f":"deep!"}}}}}}', function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    });
    return objectSerializer(proon.object);
  }, "Delete the fifth-level leaf-node", '{}', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return objectSerializer(proon.object);
  }, "Add a fifth-level leaf-node, and then insert a third-level leaf-node", '{"a":{"b":{"c":{"d":{"e":{"f":"deep!"}},"g":"middle"}}}}', function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    });
    return objectSerializer(proon.object);
  }, "Delete the fifth-level leaf-node, but not the third-level leaf-node", '{"a":{"b":{"c":{"g":"middle"}}}}', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return objectSerializer(proon.object);
  }, "Add a fifth-level leaf-node again", '{"a":{"b":{"c":{"g":"middle","d":{"e":{"f":"returned!"}}}}}}', function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'returned!'
    });
    return objectSerializer(proon.object);
  }, "Delete the third-level leaf-node, but not the fifth-level leaf-node", '{"a":{"b":{"c":{"d":{"e":{"f":"returned!"}}}}}}', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c'],
      name: 'g'
    });
    return objectSerializer(proon.object);
  }, "Delete the second-level branch-node", '{}', function(proon) {
    proon["delete"]({
      path: ['a', 'b']
    });
    return objectSerializer(proon.object);
  }, "Add fifth- and third-level leaf-nodes, and a sub-tree in the third-level", '{"a":{"b":{"c":{"d":{"e":{"f":"deep!"}},"g":"middle","p":{"q":{"r":"side"}}}}}}', function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    }).add({
      path: ['a', 'b', 'c', 'p', 'q'],
      name: 'r',
      content: 'side'
    });
    return objectSerializer(proon.object);
  }, "Delete the fourth-level branch-node", '{"a":{"b":{"c":{"g":"middle","p":{"q":{"r":"side"}}}}}}', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd']
    });
    return objectSerializer(proon.object);
  }, "Delete the 'q' branch-node", '{"a":{"b":{"c":{"g":"middle"}}}}', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'p', 'q']
    });
    return objectSerializer(proon.object);
  }, "Add a second top-level branch-node", '{"a":{"b":{"c":{"g":"middle"}}},"x":{"y":{"z":"another"}}}', function(proon) {
    proon.add({
      path: ['x', 'y'],
      name: 'z',
      content: 'another'
    });
    return objectSerializer(proon.object);
  }, "Delete everything, by specifying `path:[]`", '{}', function(proon) {
    proon["delete"]({
      path: []
    });
    return objectSerializer(proon.object);
  }, "`proon.delete()` object exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is undefined not object", function(proon) {
    return proon["delete"]();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is array not object", function(proon) {
    return proon["delete"]([]);
  }, "If set, `node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` is array not string", function(proon) {
    return proon["delete"]({
      name: []
    });
  }, "`node.name` must not be just a hyphen", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '-'
    });
  }, "`node.name` must not be just a digit", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '0'
    });
  }, "`node.name` must not be just a capital letter", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'A'
    });
  }, "`node.name` must not contain an underscore", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'fo_o'
    });
  }, "If set, `node.name` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'x' is undefined in the object", function(proon) {
    proon.add({
      name: 'c',
      path: ['a', 'b']
    });
    return proon["delete"]({
      name: 'x',
      path: ['a', 'b']
    });
  }, "If set, `node.name` must not refer to a branch-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'a' is an object branch- not leaf-node", function(proon) {
    return proon["delete"]({
      name: 'a'
    });
  }, "If set, `node.name` must not be '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '__',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path` is string not array", function(proon) {
    return proon["delete"]({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path.length` 100 > 99", function(proon) {
    return proon["delete"]({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain arrays", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is array not string", function(proon) {
    return proon.add({
      path: ['abc', ['def'], 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path`  must not contain '/'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd/ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      path: ['a', '__']
    });
  }, "If set, `node.path` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` 'x' is undefined in the object", function(proon) {
    return proon["delete"]({
      path: ['a', 'x'],
      name: 'c'
    });
  }, "If set, `node.path` must node refer to a leaf-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[2]` 'c' is an object leaf- not branch-node", function(proon) {
    return proon["delete"]({
      path: ['a', 'b', 'c']
    });
  }
]);

tudor.add([
  "03-2 Proon `delete()` storage", tudor.is, "(Set up a Proon instance with sessionStorage)", function() {
    var s;
    if (typeof window !== "undefined" && window !== null ? window.sessionStorage : void 0) {
      s = window.sessionStorage;
      s.clear();
    } else {
      s = {
        setItem: function(key, value) {
          this[key] = value;
          this.length++;
          return this.keys.push(key);
        },
        getItem: function(key) {
          return this[key] || null;
        },
        removeItem: function(key) {
          var i;
          i = this.keys.indexOf(key);
          if (-1 === i) {
            return;
          }
          this.keys.splice(i, 1);
          this.length--;
          return delete this[key];
        },
        clear: function() {
          var j, key, len, ref;
          ref = this.keys;
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            delete this[key];
          }
          this.length = 0;
          return this.keys = [];
        },
        key: function(i) {
          return this.keys[i];
        },
        length: 0,
        keys: []
      };
    }
    return [
      new Proon({
        storage: s
      })
    ];
  }, "`proon.delete()` works on storage without error", ªO, function(proon) {
    proon.storage.clear();
    proon.add({
      name: 'a'
    });
    return proon["delete"]({
      name: 'a'
    });
  }, "`proon.delete()` storage usage", tudor.equal, "`proon.storage` is empty after the previous test", '[EMPTY]', function(proon) {
    return storageSerializer(proon.storage);
  }, "Add a top-level leaf-node, `proon.add({ name:'a', content:'ok' })`", '/a -ok', function(proon) {
    proon.add({
      name: 'a',
      content: 'ok'
    });
    return storageSerializer(proon.storage);
  }, "Delete the top-level leaf-node, `proon.delete({ name:'a' })`", '[EMPTY]', function(proon) {
    proon["delete"]({
      name: 'a'
    });
    return storageSerializer(proon.storage);
  }, "Add two second-level leaf-nodes", "/a /\n/a/b -one\n/a/c -two", function(proon) {
    proon.add({
      path: ['a'],
      name: 'b',
      content: 'one'
    }).add({
      path: ['a'],
      name: 'c',
      content: 'two'
    });
    return storageSerializer(proon.storage);
  }, "Delete the first second-level leaf-node", "/a /\n/a/c -two", function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'b'
    });
    return storageSerializer(proon.storage);
  }, "Delete the second second-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'c'
    });
    return storageSerializer(proon.storage);
  }, "Add a fifth-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -deep!", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    });
    return storageSerializer(proon.storage);
  }, "Delete the fifth-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return storageSerializer(proon.storage);
  }, "Add a fifth-level leaf-node, and then insert a third-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -deep!\n/a/b/c/g -middle", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    });
    return storageSerializer(proon.storage);
  }, "Delete the fifth-level leaf-node, but not the third-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return storageSerializer(proon.storage);
  }, "Add a fifth-level leaf-node again", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -returned!\n/a/b/c/g -middle", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'returned!'
    });
    return storageSerializer(proon.storage);
  }, "Delete the third-level leaf-node, but not the fifth-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -returned!", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c'],
      name: 'g'
    });
    return storageSerializer(proon.storage);
  }, "Spike storage with an unexpected item", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -returned!\noops How unexpected", function(proon) {
    proon.storage.setItem('oops', 'How unexpected');
    return storageSerializer(proon.storage);
  }, "Delete the second-level branch-node", 'oops How unexpected', function(proon) {
    proon["delete"]({
      path: ['a', 'b']
    });
    return storageSerializer(proon.storage);
  }, "Add fifth- and third-level leaf-nodes, and a sub-tree in the third-level", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -deep!\n/a/b/c/g -middle\n/a/b/c/p /\n/a/b/c/p/q /\n/a/b/c/p/q/r -side\noops How unexpected", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    }).add({
      path: ['a', 'b', 'c', 'p', 'q'],
      name: 'r',
      content: 'side'
    });
    return storageSerializer(proon.storage);
  }, "Delete the fourth-level branch-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle\n/a/b/c/p /\n/a/b/c/p/q /\n/a/b/c/p/q/r -side\noops How unexpected", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd']
    });
    return storageSerializer(proon.storage);
  }, "Delete the 'q' branch-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle\noops How unexpected", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'p', 'q']
    });
    return storageSerializer(proon.storage);
  }, "Add a second top-level branch-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle\n/x /\n/x/y /\n/x/y/z -another\noops How unexpected", function(proon) {
    proon.add({
      path: ['x', 'y'],
      name: 'z',
      content: 'another'
    });
    return storageSerializer(proon.storage);
  }, "Delete everything, by specifying `path:[]`", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: []
    });
    return storageSerializer(proon.storage);
  }, "`proon.delete()` storage exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is undefined not object", function(proon) {
    return proon["delete"]();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is array not object", function(proon) {
    return proon["delete"]([]);
  }, "If set, `node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` is array not string", function(proon) {
    return proon["delete"]({
      name: []
    });
  }, "`node.name` must not be just a hyphen", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '-'
    });
  }, "`node.name` must not be just a digit", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '0'
    });
  }, "`node.name` must not be just a capital letter", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'A'
    });
  }, "`node.name` must not contain an underscore", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'fo_o'
    });
  }, "If set, `node.name` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'x' is undefined in storage", function(proon) {
    proon.add({
      name: 'c',
      path: ['a', 'b']
    });
    return proon["delete"]({
      name: 'x',
      path: ['a', 'b']
    });
  }, "If set, `node.name` must not refer to a branch-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'a' is a storage branch- not leaf-node", function(proon) {
    return proon["delete"]({
      name: 'a'
    });
  }, "If set, `node.name` must not be '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '__',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path` is string not array", function(proon) {
    return proon["delete"]({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path.length` 100 > 99", function(proon) {
    return proon["delete"]({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain arrays", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is array not string", function(proon) {
    return proon.add({
      path: ['abc', ['def'], 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path`  must not contain '/'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd/ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      path: ['a', '__']
    });
  }, "If set, `node.path` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` 'x' is undefined in storage", function(proon) {
    return proon["delete"]({
      path: ['a', 'x'],
      name: 'c'
    });
  }, "If set, `node.path` must node refer to a leaf-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[2]` 'c' is a storage leaf- not branch-node", function(proon) {
    return proon["delete"]({
      path: ['a', 'b', 'c']
    });
  }
]);
}).call(this,this);
// Example vendor file. 
