// Generated by CoffeeScript 1.9.2
(function(ªG) {
/*! Proon 0.0.3 //// MIT Licence //// http://proon.richplastow.com/ */
var Proon, SomeClass, Tudor, tudor, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªinsert, ªis, ªisU, ªredefine, ªtype, ªuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ªC = 'Proon';

ªV = '0.0.3';

SomeClass = (function() {
  SomeClass.prototype.C = 'SomeClass';

  SomeClass.prototype.toString = function() {
    return '[object SomeClass]';
  };

  function SomeClass(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass()\n  ";
    this.x = null;
  }

  SomeClass.prototype.xx = function(yy) {
    var M;
    return M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass:xx()\n  ";
  };

  return SomeClass;

})();

SomeClass.xx = function(yy) {
  var M;
  return M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass.xx()\n  ";
};

Proon = (function() {
  Proon.prototype.C = 'Proon';

  Proon.prototype.toString = function() {
    return '[object Proon]';
  };

  function Proon(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/proon/src/Proon.litcoffee Proon()\n  ";
    if (ªU === typeof config.object) {
      this.object = null;
    } else if (ªO !== ªtype(config.object)) {
      throw TypeError(M + "Optional `config.object` is " + (ªtype(config.object)) + " not object");
    } else {
      this.object = config.object;
    }
    if (ªU === typeof config.localStorage) {
      this.localStorage = null;
    } else if (ªO !== ªtype(config.localStorage)) {
      throw TypeError(M + "Optional `config.localStorage` is " + (ªtype(config.localStorage)) + " not object");
    } else if (ªF !== typeof config.localStorage.setItem) {
      throw TypeError(M + "Optional `config.localStorage` has no `setItem()` method");
    } else {
      this.localStorage = config.localStorage;
    }
    if (ªU === typeof config.fs) {
      this.fs = null;
    } else if (ªO !== ªtype(config.fs)) {
      throw TypeError(M + "Optional `config.fs` is " + (ªtype(config.fs)) + " not object");
    } else if (ªF !== typeof config.fs.readFileSync) {
      throw TypeError(M + "Optional `config.fs` has no `readFileSync()` method");
    } else {
      this.fs = config.fs;
    }
    if (ªU === typeof config.db) {
      this.db = null;
    } else if (ªO !== ªtype(config.db)) {
      throw TypeError(M + "Optional `config.db` is " + (ªtype(config.db)) + " not object");
    } else {
      this.db = config.db;
    }
    if (ªU === typeof config.dom) {
      this.dom = null;
    } else if (ªO !== ªtype(config.dom)) {
      throw TypeError(M + "Optional `config.dom` is " + (ªtype(config.dom)) + " not object");
    } else {
      this.dom = config.dom;
    }
  }

  Proon.prototype.add = function(node) {
    var M, content, curr, i, j, k, l, len, len1, len2, maxLen, name, nameRx, path, pathRx, str;
    M = "/proon/src/Proon.litcoffee Proon:add()\n  ";
    if (ªO !== ªtype(node)) {
      throw TypeError(M + "`node` is " + (ªtype(node)) + " not object");
    }
    name = node.name;
    path = node.path;
    content = node.content;
    nameRx = /^[a-z][-a-z0-9]{0,23}$/;
    if (ªS !== typeof name) {
      throw TypeError(M + "`node.name` is " + (ªtype(name)) + " not string");
    }
    if (!nameRx.test(name)) {
      throw RangeError(M + "`node.name` fails " + nameRx);
    }
    pathRx = /^[a-z][-a-z0-9]{0,23}$/;
    if (ªU === typeof path) {
      path = [];
    } else if (ªA !== ªtype(path)) {
      throw TypeError(M + "`node.path` is " + (ªtype(path)) + " not array");
    }
    for (i = j = 0, len = path.length; j < len; i = ++j) {
      str = path[i];
      if (ªS !== typeof str) {
        throw TypeError(M + "`node.path[" + i + "]` is " + (ªtype(path[i])) + " not string");
      }
      if (!pathRx.test(str)) {
        throw RangeError(M + "`node.path[" + i + "]` fails " + pathRx);
      }
    }
    maxLen = 1024 * 1024;
    if (ªU === typeof content) {
      content = '';
    } else if (ªS !== typeof content) {
      throw TypeError(M + "`node.content` is " + (ªtype(content)) + " not string");
    } else if (maxLen < content.length) {
      throw TypeError(M + "`node.content.length` " + content.length + " > " + maxLen);
    }
    if (this.object) {
      curr = this.object;
      for (i = k = 0, len1 = path.length; k < len1; i = ++k) {
        str = path[i];
        curr = curr[str];
        if (ªS === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is already a leaf-node");
        }
        if (ªU === typeof curr) {
          break;
        }
      }
      if (curr) {
        if (ªS === typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is already a leaf-node");
        }
        if (ªU !== typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is already a branch-node");
        }
      }
    }
    if (this.localStorage) {
      123;
    }
    if (this.fs) {
      123;
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    if (this.object) {
      curr = this.object;
      for (i = l = 0, len2 = path.length; l < len2; i = ++l) {
        str = path[i];
        if (ªU === typeof curr[str]) {
          curr[str] = {};
        }
        curr = curr[str];
      }
      curr[name] = content;
    }
    if (this.localStorage) {
      123;
    }
    if (this.fs) {
      123;
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    return this;
  };

  return Proon;

})();

Proon.xx = function(yy) {
  var M;
  return M = "/proon/src/Proon.litcoffee Proon.xx()\n  ";
};

ªA = 'array';

ªB = 'boolean';

ªE = 'error';

ªF = 'function';

ªN = 'number';

ªO = 'object';

ªR = 'regexp';

ªS = 'string';

ªU = 'undefined';

ªX = 'null';

ª = console.log.bind(console);

ªex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

ªis = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

ªhas = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

ªtype = function(x) {
  return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

ªisU = function(x) {
  return ªU === typeof x;
};

ªuid = function(p) {
  return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
};

ªinsert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

ªredefine = function(obj, name, value, kind) {
  switch (kind) {
    case 'constant':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: true
      });
    case 'private':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: false
      });
  }
};

if (ªF === typeof define && define.amd) {
  define(function() {
    return Proon;
  });
} else if (ªO === typeof module && module && module.exports) {
  module.exports = Proon;
} else {
  ªG.Proon = Proon;
}

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (ªA !== ªtype(lines)) {
      throw new Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw new Error("`lines` has no elements");
    }
    if (ªS !== ªtype(lines[0])) {
      throw new Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (ªtype(line)) {
        case ªO:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case ªF:
          section.jobs.push(line);
          break;
        case ªS:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, k, l, len, len1, len2, mock, mockFail, pge, pgeFail, pgePass, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = null;
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (k = 0, len1 = ref1.length; k < len1; k++) {
        section = ref1[k];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (l = 0, len2 = ref2.length; l < len2; l++) {
          job = ref2[l];
          switch (ªtype(job)) {
            case ªF:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case ªA:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== ªtype(result)) {
        return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (ªF !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (ªF !== ªtype(line2)) {
      return false;
    }
    if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: ªO === typeof window ? 'html' : 'plain'
});

Proon.runTest = tudor["do"];

tudor.add([
  "01 Proon Constructor", tudor.is, "The class and instance are expected types", "The Proon class is a function", ªF, function() {
    return Proon;
  }, "`new` returns an object", ªO, function() {
    return new Proon;
  }, "`config.object` exceptions", tudor["throw"], "If set, `config.object` must not be an array", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.object` is array not object", function() {
    return new Proon({
      object: []
    });
  }, "If set, `config.object` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.object` is null not object", function() {
    return new Proon({
      object: null
    });
  }, "`config.localStorage` exceptions", tudor["throw"], "If set, `config.localStorage` must not be a Date instance", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.localStorage` is date not object", function() {
    return new Proon({
      localStorage: new Date
    });
  }, "If set, `config.localStorage` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.localStorage` is null not object", function() {
    return new Proon({
      localStorage: null
    });
  }, "If `config.localStorage` is set, `config.localStorage.setItem` must be defined", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.localStorage` has no `setItem()` method", function() {
    return new Proon({
      localStorage: {}
    });
  }, "If set, `config.localStorage` must have a `setItem()` method", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.localStorage` has no `setItem()` method", function() {
    return new Proon({
      localStorage: {
        setItem: 123
      }
    });
  }, "`config.fs` exceptions", "If set, `config.fs` must not be an array", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` is array not object", function() {
    return new Proon({
      fs: []
    });
  }, "If set, `config.fs` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` is null not object", function() {
    return new Proon({
      fs: null
    });
  }, "If `config.fs` is set, `config.fs.readFileSync` must be defined", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` has no `readFileSync()` method", function() {
    return new Proon({
      fs: {}
    });
  }, "If set, `config.fs` must have a `readFileSync()` method", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` has no `readFileSync()` method", function() {
    return new Proon({
      fs: {
        readFileSync: 123
      }
    });
  }, "`config.db` exceptions", "If set, `config.localStorage` must not be the Math object", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.db` is math not object", function() {
    return new Proon({
      db: Math
    });
  }, "`config.dom` exceptions", "If set, `config.dom` must not be a regexp", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.dom` is regexp not object", function() {
    return new Proon({
      dom: /abc/
    });
  }
]);

tudor.add([
  "02 Proon `add()`", tudor.is, "The method is the expected type", function() {
    return [
      new Proon({
        object: {}
      })
    ];
  }, "`proon.add()` is a function", ªF, function(proon) {
    return proon.add;
  }, "`proon.add()` returns an object", ªO, function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "`proon.add()` exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:add()\n  `node` is undefined not object", function(proon) {
    return proon.add();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node` is array not object", function(proon) {
    return proon.add([]);
  }, "`node.name` is not optional", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` is undefined not string", function(proon) {
    return proon.add({});
  }, "`node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` is array not string", function(proon) {
    return proon.add({
      name: []
    });
  }, "`node.name` must not begin with a hyphen", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: '-foo'
    });
  }, "`node.name` must not begin with a digit", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: '3foo'
    });
  }, "`node.name` must not contain capital letters", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: 'fOo'
    });
  }, "`node.name` must not contain a dot", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: 'fo.o'
    });
  }, "`node.name` must not already be a branch-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'a' is already a branch-node", function(proon) {
    return proon.add({
      name: 'a'
    });
  }, "`node.name` must not already be a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'c' is already a leaf-node", function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path` is string not array", function(proon) {
    return proon.add({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain numbers", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is number not string", function(proon) {
    return proon.add({
      path: ['abc', 123, 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` branch-nodes must not contain '*'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd*ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not overwrite a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[2]` 'c' is already a leaf-node", function(proon) {
    return proon.add({
      name: 'd',
      path: ['a', 'b', 'c']
    });
  }, "If set, `node.content` must not be a number", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content` is number not string", function(proon) {
    return proon.add({
      name: 'foo',
      content: 123
    });
  }, "If set, `node.content.length` must 1024 * 1024 or less", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content.length` 1049599 > 1048576", function(proon) {
    return proon.add({
      name: 'foo',
      content: Array(1024 * 1025).join('x')
    });
  }
]);
}).call(this,this);
// Example vendor file. 
