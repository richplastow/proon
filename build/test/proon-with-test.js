// Generated by CoffeeScript 1.9.2
(function(ªG) {
/*! Proon 0.0.10 //// MIT Licence //// http://proon.richplastow.com/ */
var Proon, SomeClass, Tudor, storageSerializer, tudor, ª, ªA, ªB, ªC, ªE, ªF, ªN, ªO, ªR, ªS, ªU, ªV, ªX, ªex, ªhas, ªinsert, ªis, ªisU, ªredefine, ªtype, ªuid,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ªC = 'Proon';

ªV = '0.0.10';

SomeClass = (function() {
  SomeClass.prototype.C = 'SomeClass';

  SomeClass.prototype.toString = function() {
    return '[object SomeClass]';
  };

  function SomeClass(config) {
    var M;
    if (config == null) {
      config = {};
    }
    M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass()\n  ";
    this.x = null;
  }

  SomeClass.prototype.xx = function(yy) {
    var M;
    return M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass:xx()\n  ";
  };

  return SomeClass;

})();

SomeClass.xx = function(yy) {
  var M;
  return M = "/proon/src/SomeClass/SomeClass.litcoffee SomeClass.xx()\n  ";
};

Proon = (function() {
  Proon.prototype.C = 'Proon';

  Proon.prototype.toString = function() {
    return '[object Proon]';
  };

  function Proon(config) {
    var M, pwdRx, ts;
    if (config == null) {
      config = {};
    }
    M = "/proon/src/Proon.litcoffee Proon()\n  ";
    if (ªU === typeof config.object) {
      this.object = null;
    } else if (ªO !== ªtype(config.object)) {
      throw TypeError(M + "Optional `config.object` is " + (ªtype(config.object)) + " not object");
    } else {
      this.object = config.object;
    }
    ts = ªtype(config.storage);
    if (ªU === ts) {
      this.storage = null;
    } else if (ªO !== ts && 'storage' !== ts) {
      throw TypeError(M + "Optional `config.storage` is " + ts + " not object or storage");
    } else if (ªF !== typeof config.storage.setItem) {
      throw TypeError(M + "Optional `config.storage` has no `setItem()` method");
    } else {
      this.storage = config.storage;
    }
    if (ªU === typeof config.fs) {
      this.fs = null;
    } else if (ªO !== ªtype(config.fs)) {
      throw TypeError(M + "Optional `config.fs` is " + (ªtype(config.fs)) + " not object");
    } else if (ªF !== typeof config.fs.readFileSync) {
      throw TypeError(M + "Optional `config.fs` has no `readFileSync()` method");
    } else if (ªF !== typeof config.fs.statSync) {
      throw TypeError(M + "Optional `config.fs` has no `statSync()` method");
    } else if (ªF !== typeof config.fs.mkdirSync) {
      throw TypeError(M + "Optional `config.fs` has no `mkdirSync()` method");
    } else if (ªF !== typeof config.fs.writeFileSync) {
      throw TypeError(M + "Optional `config.fs` has no `writeFileSync()` method");
    } else {
      this.fs = config.fs;
    }
    if (ªU === typeof config.db) {
      this.db = null;
    } else if (ªO !== ªtype(config.db)) {
      throw TypeError(M + "Optional `config.db` is " + (ªtype(config.db)) + " not object");
    } else {
      this.db = config.db;
    }
    if (ªU === typeof config.dom) {
      this.dom = null;
    } else if (ªO !== ªtype(config.dom)) {
      throw TypeError(M + "Optional `config.dom` is " + (ªtype(config.dom)) + " not object");
    } else {
      this.dom = config.dom;
    }
    pwdRx = /^[.\/a-z0-9][-.\/a-z0-9]{0,62}[-a-z0-9]$/i;
    if (ªU === typeof config.pwd) {
      this.pwd = '.';
    } else if (ªS !== ªtype(config.pwd)) {
      throw TypeError(M + "Optional `config.pwd` is " + (ªtype(config.pwd)) + " not string");
    } else if (!pwdRx.test(config.pwd)) {
      throw RangeError(M + "Optional `config.pwd` fails " + pwdRx);
    } else {
      this.pwd = config.pwd;
    }
  }

  Proon.prototype.add = function(node) {
    var M, content, curr, e, i, j, key, len, len1, len2, len3, len4, len5, m, maxLen, maxLevels, name, nameRx, path, pathRx, q, r, real, ref, ref1, rel, stat, str, u, value, w, y;
    M = "/proon/src/Proon.litcoffee Proon:add()\n  ";
    if (ªO !== ªtype(node)) {
      throw TypeError(M + "`node` is " + (ªtype(node)) + " not object");
    }
    name = node.name;
    path = node.path;
    content = node.content;
    nameRx = /^[a-z][-a-z0-9]{0,23}$/;
    if (ªS !== typeof name) {
      throw TypeError(M + "`node.name` is " + (ªtype(name)) + " not string");
    }
    if (!nameRx.test(name)) {
      throw RangeError(M + "`node.name` fails " + nameRx);
    }
    pathRx = /^[a-z][-a-z0-9]{0,23}$/;
    maxLevels = 99;
    if (ªU === typeof path) {
      path = [];
    } else if (ªA !== ªtype(path)) {
      throw TypeError(M + "`node.path` is " + (ªtype(path)) + " not array");
    } else if (maxLevels < path.length) {
      throw RangeError(M + "`node.path.length` " + path.length + " > " + maxLevels);
    }
    for (i = j = 0, len = path.length; j < len; i = ++j) {
      str = path[i];
      if (ªS !== typeof str) {
        throw TypeError(M + "`node.path[" + i + "]` is " + (ªtype(path[i])) + " not string");
      }
      if (!pathRx.test(str)) {
        throw RangeError(M + "`node.path[" + i + "]` fails " + pathRx);
      }
    }
    maxLen = 1024 * 1024;
    if (ªU === typeof content) {
      content = '';
    } else if (ªS !== typeof content) {
      throw TypeError(M + "`node.content` is " + (ªtype(content)) + " not string");
    } else if (maxLen < content.length) {
      throw TypeError(M + "`node.content.length` " + content.length + " > " + maxLen);
    }
    if (this.object) {
      curr = this.object;
      for (i = m = 0, len1 = path.length; m < len1; i = ++m) {
        str = path[i];
        curr = curr[str];
        if (ªS === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is already an object leaf-node");
        }
        if (ªU === typeof curr) {
          break;
        }
      }
      if (curr) {
        if (ªS === typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is already an object leaf-node");
        }
        if (ªU !== typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is already an object branch-node");
        }
      }
    }
    if (this.storage) {
      key = '/';
      value = true;
      for (i = q = 0, len2 = path.length; q < len2; i = ++q) {
        str = path[i];
        value = this.storage.getItem(key += str);
        if (null === value) {
          break;
        }
        if ('/' !== value) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is already a storage leaf-node");
        }
        key += '/';
      }
      if (value) {
        value = this.storage.getItem(key += name);
        if ('/' === value) {
          throw RangeError(M + "`node.name` '" + name + "' is already a storage branch-node");
        }
        if (null !== value) {
          throw RangeError(M + "`node.name` '" + name + "' is already a storage leaf-node");
        }
      }
    }
    if (this.fs) {
      rel = this.pwd;
      real = [];
      for (i = r = 0, len3 = path.length; r < len3; i = ++r) {
        str = path[i];
        rel += '/' + str;
        try {
          stat = this.fs.statSync(rel);
        } catch (_error) {
          e = _error;
          if ('ENOENT' === e.code) {
            break;
          }
          throw Error("" + M + e.code + " checking `node.path[" + i + "]` '" + str + "'");
        }
        if (!stat.isDirectory()) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is already a file");
        }
        real.push(str);
      }
      if (real.length === path.length) {
        e = {
          code: false
        };
        rel += '/' + name;
        try {
          stat = this.fs.statSync(rel);
        } catch (_error) {
          e = _error;
          if ('ENOENT' !== e.code) {
            throw Error("" + M + e.code + " checking `node.name` '" + name + "'");
          }
        }
        if (!e.code) {
          if (stat.isFile()) {
            throw RangeError(M + "`node.name` '" + name + "' is already a file");
          }
          if (stat.isDirectory()) {
            throw RangeError(M + "`node.name` '" + name + "' is already a directory");
          }
        }
      }
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    if (this.object) {
      curr = this.object;
      for (i = u = 0, len4 = path.length; u < len4; i = ++u) {
        str = path[i];
        if (ªU === typeof curr[str]) {
          curr[str] = {
            __: curr
          };
        }
        curr = curr[str];
      }
      curr[name] = content;
    }
    if (this.storage) {
      key = '/';
      for (i = w = 0, len5 = path.length; w < len5; i = ++w) {
        str = path[i];
        if (null === this.storage.getItem(key = "" + key + str)) {
          this.storage.setItem(key, '/');
        }
        key += '/';
      }
      key = "" + key + name;
      this.storage.setItem(key, '-' + content);
    }
    if (this.fs) {
      rel = rel.replace(/\/[^\/]+$/, '');
      if (real.length !== path.length) {
        for (i = y = ref = real.length, ref1 = path.length - 1; ref <= ref1 ? y <= ref1 : y >= ref1; i = ref <= ref1 ? ++y : --y) {
          rel += '/' + path[i];
          try {
            this.fs.mkdirSync(rel);
          } catch (_error) {
            e = _error;
            throw Error("" + M + e.code + " making `node.path[" + i + "]` '" + str + "'");
          }
        }
      }
      try {
        this.fs.writeFileSync(rel + '/' + name, content);
      } catch (_error) {
        e = _error;
        throw Error("" + M + e.code + " making `node.name` '" + name + "'");
      }
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    return this;
  };

  Proon.prototype["delete"] = function(node) {
    var M, curr, e, i, items, j, k, key, l, len, len1, len2, len3, len4, len5, m, maxLevels, name, nameRx, path, pathRx, q, r, ref, ref1, rel, stat, str, subs, u, value, w, y, z;
    M = "/proon/src/Proon.litcoffee Proon:delete()\n  ";
    if (ªO !== ªtype(node)) {
      throw TypeError(M + "`node` is " + (ªtype(node)) + " not object");
    }
    name = node.name;
    path = node.path;
    nameRx = /^[a-z][-a-z0-9]{0,23}$/;
    if (ªU === typeof name) {
      name = false;
    } else if (ªS !== typeof name) {
      throw TypeError(M + "`node.name` is " + (ªtype(name)) + " not string");
    } else if (!nameRx.test(name)) {
      throw RangeError(M + "`node.name` fails " + nameRx);
    }
    pathRx = /^[a-z][-a-z0-9]{0,23}$/;
    maxLevels = 99;
    if (ªU === typeof path) {
      path = [];
    } else if (ªA !== ªtype(path)) {
      throw TypeError(M + "`node.path` is " + (ªtype(path)) + " not array");
    } else if (maxLevels < path.length) {
      throw RangeError(M + "`node.path.length` " + path.length + " > " + maxLevels);
    }
    for (i = j = 0, len = path.length; j < len; i = ++j) {
      str = path[i];
      if (ªS !== typeof str) {
        throw TypeError(M + "`node.path[" + i + "]` is " + (ªtype(path[i])) + " not string");
      }
      if (!pathRx.test(str)) {
        throw RangeError(M + "`node.path[" + i + "]` fails " + pathRx);
      }
    }
    if (this.object) {
      curr = this.object;
      for (i = m = 0, len1 = path.length; m < len1; i = ++m) {
        str = path[i];
        curr = curr[str];
        if (ªU === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is undefined in the object");
        }
        if (ªS === typeof curr) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is an object leaf- not branch-node");
        }
      }
      if (name) {
        if (ªU === typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is undefined in the object");
        }
        if (ªS !== typeof curr[name]) {
          throw RangeError(M + "`node.name` '" + name + "' is an object branch- not leaf-node");
        }
      }
    }
    if (this.storage) {
      key = '/';
      for (i = q = 0, len2 = path.length; q < len2; i = ++q) {
        str = path[i];
        value = this.storage.getItem(key += str);
        if (null === value) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is undefined in storage");
        }
        if ('/' !== value) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is a storage leaf- not branch-node");
        }
        key += '/';
      }
      if (name) {
        value = this.storage.getItem(key + name);
        if (null === value) {
          throw RangeError(M + "`node.name` '" + name + "' is undefined in storage");
        }
        if ('/' === value) {
          throw RangeError(M + "`node.name` '" + name + "' is a storage branch- not leaf-node");
        }
      }
    }
    if (this.fs) {
      rel = this.pwd;
      for (i = r = 0, len3 = path.length; r < len3; i = ++r) {
        str = path[i];
        rel += '/' + str;
        try {
          stat = this.fs.statSync(rel);
        } catch (_error) {
          e = _error;
          if ('ENOENT' === e.code) {
            throw RangeError(M + "`node.path[" + i + "]` '" + str + "' does not exist in filesystem");
          }
          throw Error("" + M + e.code + " checking `node.path[" + i + "]` '" + str + "'");
        }
        if (!stat.isDirectory()) {
          throw RangeError(M + "`node.path[" + i + "]` '" + str + "' is a file, not a directory");
        }
      }
      if (name) {
        rel += '/' + name;
        try {
          stat = this.fs.statSync(rel);
        } catch (_error) {
          e = _error;
          if ('ENOENT' === e.code) {
            throw RangeError(M + "`node.name` '" + name + "' does not exist in filesystem");
          }
          throw Error("" + M + e.code + " checking `node.name` '" + name + "'");
        }
        if (stat.isDirectory()) {
          throw RangeError(M + "`node.name` '" + name + "' is a directory, not a file");
        }
      }
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    if (this.object) {
      curr = this.object;
      for (i = u = 0, len4 = path.length; u < len4; i = ++u) {
        str = path[i];
        curr = curr[str];
      }
      if (name) {
        delete curr[name];
      } else if (0 === path.length) {
        this.object = {};
      } else if (str = path[--i]) {
        curr = curr.__;
        delete curr[str];
      }
      while (str = path[--i]) {
        curr = curr.__;
        if (1 === Object.keys(curr[str]).length) {
          delete curr[str];
        }
      }
    }
    if (this.storage) {
      key = path.length ? '/' + path.join('/') : '';
      if (name) {
        this.storage.removeItem(key + '/' + name);
      } else if (0 === path.length) {
        this.storage.clear();
      } else {
        this.storage.removeItem(key);
        l = key.length;
        subs = [];
        for (i = w = 0, ref = this.storage.length - 1; 0 <= ref ? w <= ref : w >= ref; i = 0 <= ref ? ++w : --w) {
          if ((k = this.storage.key(i)) && k.substr(0, l) === key) {
            subs.push(k);
          }
        }
        for (y = 0, len5 = subs.length; y < len5; y++) {
          k = subs[y];
          this.storage.removeItem(k);
        }
      }
      outer: //;
      while (key) {
        l = key.length;
        for (i = z = 0, ref1 = this.storage.length - 1; 0 <= ref1 ? z <= ref1 : z >= ref1; i = 0 <= ref1 ? ++z : --z) {
          if ((k = this.storage.key(i)) !== key && k.substr(0, l) === key) {
            break outer;
          }
        }
        this.storage.removeItem(key);
        key = key.replace(/\/[^\/]+$/, '');
      }
    }
    if (this.fs) {
      rel = path.length ? this.pwd + '/' + path.join('/') : this.pwd;
      if (name) {
        try {
          this.fs.unlinkSync(rel + '/' + name);
        } catch (_error) {
          e = _error;
          throw Error("" + M + e.code + " deleting `node.name` '" + name + "'");
        }
      } else if (0 === path.length) {
        this._fsClear();
      } else {
        this._fsClear(rel);
      }
      while (rel.length > this.pwd.length) {
        try {
          items = this.fs.readdirSync(rel);
        } catch (_error) {
          e = _error;
          throw Error("" + M + e.code + " deleting directory '" + rel + "'");
        }
        if (0 !== items.length) {
          break;
        }
        this.fs.rmdirSync(rel);
        rel = rel.replace(/\/[^\/]+$/, '');
      }
    }
    if (this.db) {
      123;
    }
    if (this.dom) {
      123;
    }
    return this;
  };

  Proon.prototype._objectSerializer = function() {
    var M, items, prefix, recurse;
    M = "/proon/src/Proon.litcoffee _objectSerializer()\n  ";
    recurse = function(o, p) {
      var isLeaf, k, v;
      if (p == null) {
        p = '';
      }
      for (k in o) {
        v = o[k];
        if ('__' === k) {
          continue;
        }
        isLeaf = ªS === typeof v;
        items.push(p + k + (isLeaf && v ? ' ' + v : ''));
        if (isLeaf) {
          continue;
        }
        prefix.push(k);
        recurse(v, prefix.join('/') + '/');
      }
      prefix.pop();
      return void 0;
    };
    items = [];
    prefix = [];
    recurse(this.object);
    if (0 === items.length) {
      return '[EMPTY]';
    }
    return items.sort().join('\n');
  };

  Proon.prototype._fsSerializer = function(pwd) {
    var M, item, items, j, l, len, len1, m, ref, stat, sub, subs;
    if (pwd == null) {
      pwd = this.pwd;
    }
    M = "/proon/src/Proon.litcoffee _fsSerializer()\n  ";
    items = this.fs.readdirSync(pwd);
    if (0 === items.length) {
      return '[EMPTY]';
    }
    for (j = 0, len = items.length; j < len; j++) {
      item = items[j];
      stat = this.fs.statSync(pwd + '/' + item);
      if (stat.isDirectory()) {
        subs = this._fsSerializer(pwd + '/' + item);
        if ('[EMPTY]' === sub) {
          continue;
        }
        ref = subs.split('\n');
        for (m = 0, len1 = ref.length; m < len1; m++) {
          sub = ref[m];
          items.push(item + '/' + sub);
        }
      }
    }
    l = pwd.length;
    return items.sort().join('\n');
  };

  Proon.prototype._fsClear = function(start) {
    var M, e, item, items, j, len, ref, results, stat;
    if (start == null) {
      start = this.pwd;
    }
    M = "/proon/src/Proon.litcoffee _fsClear()\n  ";
    items = this._fsSerializer(start);
    if ('[EMPTY]' === items) {
      return;
    }
    ref = items.split('\n').reverse();
    results = [];
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      try {
        stat = this.fs.statSync(start + '/' + item);
      } catch (_error) {
        e = _error;
        throw Error("" + M + e.code + " checking '" + item + "'");
      }
      if (stat.isDirectory()) {
        try {
          results.push(this.fs.rmdirSync(start + '/' + item));
        } catch (_error) {
          e = _error;
          throw Error("" + M + e.code + " deleting directory '" + item + "'");
        }
      } else {
        try {
          results.push(this.fs.unlinkSync(start + '/' + item));
        } catch (_error) {
          e = _error;
          throw Error("" + M + e.code + " deleting file '" + item + "'");
        }
      }
    }
    return results;
  };

  return Proon;

})();

if (!Function.prototype.bind) {
  Function.prototype.bind = function(oThis) {
    var aArgs, fBound, fNOP, fToBind;
    if ('function' !== typeof this) {
      throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
    }
    aArgs = Array.prototype.slice.call(arguments, 1);
    fToBind = this;
    fNOP = function() {};
    fBound = function() {
      return fToBind.apply((this instanceof fNOP ? this : oThis), aArgs.concat(Array.prototype.slice.call(arguments)));
    };
    if (this.prototype) {
      fNOP.prototype = this.prototype;
    }
    fBound.prototype = new fNOP();
    return fBound;
  };
}

ªA = 'array';

ªB = 'boolean';

ªE = 'error';

ªF = 'function';

ªN = 'number';

ªO = 'object';

ªR = 'regexp';

ªS = 'string';

ªU = 'undefined';

ªX = 'null';

ª = console.log.bind(console);

ªex = function(x, a, b) {
  var pos;
  if (-1 === (pos = a.indexOf(x))) {
    return x;
  } else {
    return b.charAt(pos);
  }
};

ªis = function(c, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (c) {
    return t;
  } else {
    return f;
  }
};

ªhas = function(h, n, t, f) {
  if (t == null) {
    t = true;
  }
  if (f == null) {
    f = false;
  }
  if (-1 !== h.indexOf(n)) {
    return t;
  } else {
    return f;
  }
};

ªtype = function(x) {
  return {}.toString.call(x).match(/\s([a-z0-9]+)/i)[1].toLowerCase();
};

ªisU = function(x) {
  return ªU === typeof x;
};

ªuid = function(p) {
  return p + '_' + (Math.random() + '1111111111111111').slice(2, 18);
};

ªinsert = function(basis, overlay, offset) {
  return basis.slice(0, offset) + overlay + basis.slice(offset + overlay.length);
};

ªredefine = function(obj, name, value, kind) {
  switch (kind) {
    case 'constant':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: true
      });
    case 'private':
      return Object.defineProperty(obj, name, {
        value: value,
        enumerable: false
      });
  }
};

if (ªF === typeof define && define.amd) {
  define(function() {
    return Proon;
  });
} else if (ªO === typeof module && module && module.exports) {
  module.exports = Proon;
} else {
  ªG.Proon = Proon;
}

Tudor = (function() {
  Tudor.prototype.I = 'Tudor';

  Tudor.prototype.toString = function() {
    return "[object " + I + "]";
  };

  Tudor.prototype.articles = [];

  function Tudor(opt) {
    this.opt = opt != null ? opt : {};
    this["do"] = bind(this["do"], this);
    switch (this.opt.format) {
      case 'html':
        this.pageHead = function(summary) {
          return "<style>\n  body     { font-family: sans-serif; }\n  a        { outline: 0; }\n  b        { display: inline-block; width: .7em }\n\n  b.pass              { color: #393 }\n  b.fail              { color: #bbb }\n  article.fail b.pass { color: #bbb }\n  section.fail b.pass { color: #bbb }\n\n  pre      { padding: .5em; margin: .2em 0; border-radius: 4px; }\n  pre.fn   { background-color: #fde }\n  pre.pass { background-color: #cfc }\n  pre.fail { background-color: #d8e0e8 }\n\n  article  { margin-bottom: .5rem }\n  article h2 { padding-left:.5rem; margin:0; font-weight:normal }\n  article.pass { border-left: 5px solid #9c9 }\n  article.fail { border-left: 5px solid #9bf }\n  article.fail h2 { margin-bottom: .5rem }\n  article.pass >div { display: none }\n\n  section  { margin-bottom: .5rem }\n  section h3   { padding-left: .5rem; margin: 0; }\n  section.pass { border-left: 3px solid #9c9 }\n  section.fail { border-left: 3px solid #9bf }\n  section.fail h3 { margin-bottom: .5rem }\n  section.pass >div { display: none }\n\n  article.fail section.pass { border-left-color: #ccc }\n\n  div      { padding-left: .5em; }\n  div.fail { border-left: 3px solid #9bf; font-size: .8rem }\n  div h4   { margin: 0 }\n  div h4 { font: normal .8rem/1.2rem monaco, monospace }\n  div.fail, div.fail h4 { margin: .5rem 0 }\n\n</style>\n<h4><a href=\"#end\" id=\"top\">\u2b07</a>  " + summary + "</h4>";
        };
        this.pageFoot = function(summary) {
          return "<h4><a href=\"#top\" id=\"end\">\u2b06</a>  " + summary + "</h4>\n<script>\n  document.title='" + (summary.replace(/<\/?[^>]+>/g, '')) + "';\n</script>";
        };
        this.articleHead = function(heading, fail) {
          return ("<article class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h2>" + (fail ? this.cross : this.tick) + heading + "</h2><div>");
        };
        this.articleFoot = '</div></article>';
        this.sectionHead = function(heading, fail) {
          return ("<section class=\"" + (fail ? 'fail' : 'pass') + "\">") + ("<h3>" + (fail ? this.cross : this.tick) + heading + "</h3><div>");
        };
        this.sectionFoot = '</div></section>';
        this.jobFormat = function(heading, result) {
          return ("<div class=\"" + (result ? 'fail' : 'pass') + "\">") + ("<h4>" + (result ? this.cross : this.tick) + heading + "</h4>") + ("" + (result ? this.formatError(result) : '')) + "</div>";
        };
        this.tick = '<b class="pass">\u2713</b> ';
        this.cross = '<b class="fail">\u2718</b> ';
        break;
      default:
        this.pageHead = function(summary) {
          return "" + summary;
        };
        this.pageFoot = function(summary) {
          return "\n" + summary;
        };
        this.articleHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n===" + (new Array(heading.length).join('=')) + "\n";
        };
        this.articleFoot = '';
        this.sectionHead = function(heading, fail) {
          return "\n" + (fail ? this.cross : this.tick) + " " + heading + "\n---" + (new Array(heading.length).join('-')) + "\n";
        };
        this.sectionFoot = '';
        this.jobFormat = function(heading, result) {
          return ((result ? this.cross : this.tick) + " " + heading) + ("" + (result ? '\n' + this.formatError(result) : ''));
        };
        this.jobFoot = '';
        this.tick = '\u2713';
        this.cross = '\u2718';
    }
  }

  Tudor.prototype.add = function(lines) {
    var article, i, line, runner, section;
    article = {
      sections: []
    };
    runner = null;
    section = null;
    if (ªA !== ªtype(lines)) {
      throw new Error("`lines` isn’t an array");
    }
    if (0 === lines.length) {
      throw new Error("`lines` has no elements");
    }
    if (ªS !== ªtype(lines[0])) {
      throw new Error("`lines[0]` isn’t a string");
    }
    article.heading = lines.shift();
    i = 0;
    while (i < lines.length) {
      line = lines[i];
      switch (ªtype(line)) {
        case ªO:
          if (!line.runner) {
            throw new Error("Errant object");
          }
          runner = line.runner;
          break;
        case ªF:
          section.jobs.push(line);
          break;
        case ªS:
          if (this.isAssertion(lines[i + 1], lines[i + 2])) {
            if (!section) {
              throw new Error("Cannot add an assertion here");
            }
            section.jobs.push([runner, line, lines[++i], lines[++i]]);
          } else {
            section = {
              heading: line,
              jobs: []
            };
            article.sections.push(section);
          }
      }
      i++;
    }
    return this.articles.push(article);
  };

  Tudor.prototype["do"] = function() {
    var actual, art, artFail, artPass, article, e, error, expect, heading, j, job, len, len1, len2, m, mock, mockFail, pge, pgeFail, pgePass, q, ref, ref1, ref2, result, runner, sec, secFail, secPass, section, summary;
    pge = [];
    mock = null;
    pgePass = pgeFail = mockFail = 0;
    ref = this.articles;
    for (j = 0, len = ref.length; j < len; j++) {
      article = ref[j];
      art = [];
      artPass = artFail = 0;
      ref1 = article.sections;
      for (m = 0, len1 = ref1.length; m < len1; m++) {
        section = ref1[m];
        sec = [];
        secPass = secFail = 0;
        ref2 = section.jobs;
        for (q = 0, len2 = ref2.length; q < len2; q++) {
          job = ref2[q];
          switch (ªtype(job)) {
            case ªF:
              try {
                mock = job.apply(this, mock);
              } catch (_error) {
                e = _error;
                error = e.message;
              }
              if (error) {
                mockFail++;
                secFail++;
                sec.push(this.formatMockModifierError(job, error));
              }
              break;
            case ªA:
              runner = job[0], heading = job[1], expect = job[2], actual = job[3];
              result = runner(expect, actual, mock);
              if (!result) {
                sec.push(this.jobFormat("" + (this.sanitize(heading))));
                pgePass++;
                artPass++;
                secPass++;
              } else {
                sec.push(this.jobFormat("" + (this.sanitize(heading)), result));
                pgeFail++;
                artFail++;
                secFail++;
              }
          }
        }
        sec.unshift(this.sectionHead("" + (this.sanitize(section.heading)), secFail));
        sec.push(this.sectionFoot);
        art = art.concat(sec);
      }
      art.unshift(this.articleHead("" + (this.sanitize(article.heading)), artFail));
      art.push(this.articleFoot);
      pge = pge.concat(art);
      summary = pgeFail ? this.cross + " FAILED " + pgeFail + "/" + (pgePass + pgeFail) : this.tick + " Passed " + pgePass + "/" + (pgePass + pgeFail);
      if (mockFail) {
        summary = "\n" + this.cross + " (MOCK FAILS)";
      }
    }
    pge.unshift(this.pageHead(summary));
    pge.push(this.pageFoot(summary));
    return pge.join('\n');
  };

  Tudor.prototype.formatError = function(result) {
    switch (result.length + "-" + this.opt.format) {
      case '2-html':
        return result[0] + "\n<pre class=\"fail\">" + (this.sanitize(result[1].message)) + "</pre>";
      case '2-plain':
        return result[0] + "\n" + (this.sanitize(result[1].message));
      case '3-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + "</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + "</pre>";
      case '3-plain':
        return (this.sanitize(this.reveal(result[0]))) + "\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2])));
      case '4-html':
        return "<pre class=\"fail\">" + (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")</pre>\n..." + result[1] + "...\n<pre class=\"pass\">" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")</pre>";
      case '4-plain':
        return (this.sanitize(this.reveal(result[0]))) + " (" + (ªtype(result[0])) + ")\n..." + result[1] + "...\n" + (this.sanitize(this.reveal(result[2]))) + " (" + (ªtype(result[2])) + ")";
      default:
        throw new Error("Cannot process '" + result.length + "-" + this.opt.format + "'");
    }
  };

  Tudor.prototype.formatMockModifierError = function(fn, error) {
    switch (this.opt.format) {
      case 'html':
        return "<pre class=\"fn\">" + (this.sanitize(fn + '')) + "</pre>\n...encountered an exception:\n<pre class=\"fail\">" + (this.sanitize(error)) + "</pre>";
      default:
        return (this.sanitize(fn + '')) + "\n...encountered an exception:\n" + (this.sanitize(error));
    }
  };

  Tudor.prototype.reveal = function(value) {
    return value != null ? value.toString().replace(/^\s+|\s+$/g, function(match) {
      return '\u00b7' + (new Array(match.length)).join('\u00b7');
    }) : void 0;
  };

  Tudor.prototype.sanitize = function(value) {
    switch (this.opt.format) {
      case 'html':
        return value != null ? value.toString().replace(/</g, '&lt;') : void 0;
      default:
        return value;
    }
  };

  Tudor.prototype["throw"] = {
    runner: function(expect, actual, mock) {
      var e, error;
      error = false;
      try {
        actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (!error) {
        return [
          'No exception thrown, expected', {
            message: expect
          }
        ];
      } else if (expect !== error.message) {
        return [error.message, 'was thrown, but expected', expect];
      }
    }
  };

  Tudor.prototype.equal = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== result) {
        if (result + '' === expect + '') {
          return [result, 'was returned, but expected', expect, true];
        } else {
          return [result, 'was returned, but expected', expect];
        }
      }
    }
  };

  Tudor.prototype.is = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (expect !== ªtype(result)) {
        return ["type " + (ªtype(result)), 'was returned, but expected', "type " + expect];
      }
    }
  };

  Tudor.prototype.match = {
    runner: function(expect, actual, mock) {
      var e, error, result;
      error = false;
      try {
        result = actual.apply(this, mock);
      } catch (_error) {
        e = _error;
        error = e;
      }
      if (error) {
        return ['Unexpected exception', error];
      } else if (ªF !== typeof expect.test) {
        return [
          '`test()` is not a function', {
            message: expect
          }
        ];
      } else if (!expect.test('' + result)) {
        return ['' + result, 'failed test', expect];
      }
    }
  };

  Tudor.prototype.isAssertion = function(line1, line2) {
    if (ªF !== ªtype(line2)) {
      return false;
    }
    if ((ªO === ªtype(line1)) && ªF === ªtype(line1.runner)) {
      return false;
    }
    return true;
  };

  return Tudor;

})();

tudor = new Tudor({
  format: ªO === typeof window ? 'html' : 'plain'
});

Proon.runTest = tudor["do"];

storageSerializer = function(s) {
  var i, j, out, ref;
  if (0 === s.length) {
    return '[EMPTY]';
  }
  out = [];
  for (i = j = 0, ref = s.length - 1; 0 <= ref ? j <= ref : j >= ref; i = 0 <= ref ? ++j : --j) {
    out.push(s.key(i) + ' ' + s.getItem([s.key(i)]));
  }
  return out.sort().join('\n');
};

tudor.add([
  "01 Proon Constructor", tudor.is, "The class and instance are expected types", "The Proon class is a function", ªF, function() {
    return Proon;
  }, "`new` returns an object", ªO, function() {
    return new Proon;
  }, "`config.object` exceptions", tudor["throw"], "If set, `config.object` must not be an array", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.object` is array not object", function() {
    return new Proon({
      object: []
    });
  }, "If set, `config.object` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.object` is null not object", function() {
    return new Proon({
      object: null
    });
  }, "`config.storage` exceptions", tudor["throw"], "If set, `config.storage` must not be a Date instance", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` is date not object or storage", function() {
    return new Proon({
      storage: new Date
    });
  }, "If set, `config.storage` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` is null not object or storage", function() {
    return new Proon({
      storage: null
    });
  }, "If `config.storage` is set, `config.storage.setItem` must be defined", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` has no `setItem()` method", function() {
    return new Proon({
      storage: {}
    });
  }, "If set, `config.storage` must have a `setItem()` method", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.storage` has no `setItem()` method", function() {
    return new Proon({
      storage: {
        setItem: 123
      }
    });
  }, "`config.fs` exceptions", "If set, `config.fs` must not be an array", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` is array not object", function() {
    return new Proon({
      fs: []
    });
  }, "If set, `config.fs` must not be null", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` is null not object", function() {
    return new Proon({
      fs: null
    });
  }, "If `config.fs` is set, `config.fs.readFileSync` must be defined", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` has no `readFileSync()` method", function() {
    return new Proon({
      fs: {}
    });
  }, "If set, `config.fs` must have a `readFileSync()` method", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.fs` has no `readFileSync()` method", function() {
    return new Proon({
      fs: {
        readFileSync: 123
      }
    });
  }, "`config.db` exceptions", "If set, `config.db` must not be the Math object", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.db` is math not object", function() {
    return new Proon({
      db: Math
    });
  }, "`config.dom` exceptions", "If set, `config.dom` must not be a regexp", "/proon/src/Proon.litcoffee Proon()\n  Optional `config.dom` is regexp not object", function() {
    return new Proon({
      dom: /abc/
    });
  }
]);

tudor.add([
  "02-1 Proon `add()` object", tudor.is, "The method is the expected type", function() {
    return [
      new Proon({
        object: {}
      })
    ];
  }, "`proon.add()` is a function", ªF, function(proon) {
    return proon.add;
  }, "`proon.add()` returns an object", ªO, function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "`proon.add()` object exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:add()\n  `node` is undefined not object", function(proon) {
    return proon.add();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node` is array not object", function(proon) {
    return proon.add([]);
  }, "`node.name` is not optional", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` is undefined not string", function(proon) {
    return proon.add({});
  }, "`node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` is array not string", function(proon) {
    return proon.add({
      name: []
    });
  }, "`node.name` must not begin with a hyphen", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: '-foo'
    });
  }, "`node.name` must not begin with a digit", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: '3foo'
    });
  }, "`node.name` must not contain capital letters", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: 'fOo'
    });
  }, "`node.name` must not contain a dot", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      name: 'fo.o'
    });
  }, "`node.name` must not already be a branch-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'a' is already an object branch-node", function(proon) {
    return proon.add({
      name: 'a'
    });
  }, "`node.name` must not already be a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'c' is already an object leaf-node", function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path` is string not array", function(proon) {
    return proon.add({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path.length` 100 > 99", function(proon) {
    return proon.add({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain numbers", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is number not string", function(proon) {
    return proon.add({
      path: ['abc', 123, 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '*'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd*ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not overwrite a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[2]` 'c' is already an object leaf-node", function(proon) {
    return proon.add({
      name: 'd',
      path: ['a', 'b', 'c']
    });
  }, "If set, `node.content` must not be a number", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content` is number not string", function(proon) {
    return proon.add({
      name: 'foo',
      content: 123
    });
  }, "If set, `node.content.length` must 1024 * 1024 or less", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content.length` 1049599 > 1048576", function(proon) {
    return proon.add({
      name: 'foo',
      content: Array(1024 * 1025).join('x')
    });
  }, "`proon.add()` object usage", tudor.equal, "`proon.object` stringifies as expected", "a\na/b\na/b/c", function(proon) {
    return proon._objectSerializer();
  }
]);

tudor.add([
  "02-2 Proon `add()` storage", tudor.is, "(Set up a Proon instance with sessionStorage)", function() {
    var s;
    if (typeof window !== "undefined" && window !== null ? window.sessionStorage : void 0) {
      s = window.sessionStorage;
      s.clear();
    } else {
      s = {
        setItem: function(key, value) {
          this[key] = value;
          this.length++;
          return this.keys.push(key);
        },
        getItem: function(key) {
          return this[key] || null;
        },
        removeItem: function(key) {
          var i;
          i = this.keys.indexOf(key);
          if (-1 === i) {
            return;
          }
          this.keys.splice(i, 1);
          this.length--;
          return delete this[key];
        },
        clear: function() {
          var j, key, len, ref;
          ref = this.keys;
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            delete this[key];
          }
          this.length = 0;
          return this.keys = [];
        },
        key: function(i) {
          return this.keys[i];
        },
        length: 0,
        keys: []
      };
    }
    return [
      new Proon({
        storage: s
      })
    ];
  }, "`proon.add()` records to storage without error", ªO, function(proon) {
    var result;
    return result = proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "`proon.add()` storage exceptions", tudor["throw"], "`node.name` must not already be a branch-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'a' is already a storage branch-node", function(proon) {
    return proon.add({
      name: 'a'
    });
  }, "`node.name` must not already be a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'c' is already a storage leaf-node", function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not overwrite a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[2]` 'c' is already a storage leaf-node", function(proon) {
    return proon.add({
      name: 'd',
      path: ['a', 'b', 'c']
    });
  }, "If set, `node.content` must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content` is array not string", function(proon) {
    return proon.add({
      name: 'foo',
      content: ['abc']
    });
  }, "`proon.add()` storage usage", tudor.equal, "`proon.storage` contains the expected key/value pairs", "/a /\n/a/b /\n/a/b/c -", function(proon) {
    return storageSerializer(proon.storage);
  }
]);

tudor.add([
  "02-3 Proon `add()` fs", tudor.is, "(Set up a Proon instance with fs)", function() {
    var e, fs, fsMock;
    fsMock = {
      paths: {},
      readFileSync: function(path) {
        var err;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        if ('/' === this.paths[path]) {
          err = Error("EISDIR, illegal operation on a directory");
          err.code = 'EISDIR';
          throw err;
        }
        return this.paths[path];
      },
      writeFileSync: function(path, content) {
        return this.paths[path] = '-' + content;
      },
      mkdirSync: function(path) {
        var err, parent;
        if (this.paths[path]) {
          err = Error("EEXIST, file already exists '" + path + "'");
          err.code = 'EEXIST';
          throw err;
        }
        parent = path.replace(/\/[^\/]+$/, '');
        if (parent && '.' !== parent && !this.paths[parent]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        return this.paths[path] = '/';
      },
      unlinkSync: function(path) {
        var err;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        if ('/' === this.paths[path]) {
          err = Error("EPERM, operation not permitted '" + path + "'");
          err.code = 'EPERM';
          throw err;
        }
        return delete this.paths[path];
      },
      rmdirSync: function(path) {
        var content, err, l, p, ref;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        if ('/' !== this.paths[path]) {
          err = Error("ENOTDIR, not a directory '" + path + "'");
          err.code = 'ENOTDIR';
          throw err;
        }
        l = path.length;
        ref = this.paths;
        for (p in ref) {
          content = ref[p];
          if (p === path) {
            continue;
          }
          if (p.substr(0, l) === path) {
            err = Error("ENOTEMPTY, directory not empty '" + path + "'");
            err.code = 'ENOTEMPTY';
            throw err;
          }
        }
        delete this.paths[path];
        return void 0;
      },
      readdirSync: function(path) {
        var content, err, items, l, p, ref;
        if (path == null) {
          path = '';
        }
        if (path) {
          if (!this.paths[path]) {
            err = Error("ENOENT, no such file or directory '" + path + "'");
            err.code = 'ENOENT';
            throw err;
          }
          if ('/' !== this.paths[path]) {
            err = Error("ENOTDIR, not a directory '" + path + "'");
            err.code = 'ENOTDIR';
            throw err;
          }
        }
        items = [];
        l = path.length;
        ref = this.paths;
        for (p in ref) {
          content = ref[p];
          if (p === path) {
            continue;
          }
          if (p.substr(0, l) === path) {
            if (-1 === p.substr(l + 1).indexOf('/')) {
              items.push(p.substr(l + 1));
            }
          }
        }
        return items;
      },
      statSync: function(path) {
        var err, that;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        that = this;
        return {
          isFile: function() {
            return that.paths[path] && '/' !== that.paths[path];
          },
          isDirectory: function() {
            return that.paths[path] && '/' === that.paths[path];
          }
        };
      }
    };
    if (ªF !== typeof require) {
      fs = fsMock;
    } else {
      try {
        fs = require('fs');
      } catch (_error) {
        e = _error;
        fs = fsMock;
      }
    }
    try {
      fs.mkdirSync('./test');
    } catch (_error) {
      e = _error;
      if ('EEXIST' !== e.code) {
        throw e;
      }
    }
    fs.mkdirSync('./test/tmp');
    return [
      new Proon({
        fs: fs,
        pwd: './test/tmp'
      })
    ];
  }, "`proon.add()` records to filesytem without error", ªO, function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    }).add({
      name: 'd',
      content: 'ok'
    });
  }, "`proon.add()` filesytem exceptions", tudor["throw"], "`node.name` must not already be a branch-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'a' is already a directory", function(proon) {
    return proon.add({
      name: 'a'
    });
  }, "`node.name` must not already be a top-level leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'd' is already a file", function(proon) {
    return proon.add({
      name: 'd'
    });
  }, "`node.name` must not already be a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.name` 'c' is already a file", function(proon) {
    return proon.add({
      name: 'c',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not overwrite a leaf-node", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[2]` 'c' is already a file", function(proon) {
    return proon.add({
      name: 'nope',
      path: ['a', 'b', 'c']
    });
  }, "If set, `node.content` must not be an array", "/proon/src/Proon.litcoffee Proon:add()\n  `node.content` is array not string", function(proon) {
    return proon.add({
      name: 'foo',
      content: ['abc']
    });
  }, "`proon.add()` cleanup", tudor.equal, "`proon.filesytem` as expected before cleanup", "a\na/b\na/b/c\nd", function(proon) {
    return proon._fsSerializer();
  }, "(Clean up filesystem)", void 0, function(proon) {
    proon.fs.unlinkSync(proon.pwd + '/d');
    proon.fs.unlinkSync(proon.pwd + '/a/b/c');
    proon.fs.rmdirSync(proon.pwd + '/a/b');
    proon.fs.rmdirSync(proon.pwd + '/a');
    return proon.fs.rmdirSync('./test/tmp');
  }
]);

tudor.add([
  "03-1 Proon `delete()` object", tudor.is, "The method is the expected type", function() {
    return [
      new Proon({
        object: {}
      })
    ];
  }, "`proon.delete()` is a function", ªF, function(proon) {
    return proon["delete"];
  }, "`proon.delete()` returns an object", ªO, function(proon) {
    proon.add({
      name: 'a'
    });
    return proon["delete"]({
      name: 'a'
    });
  }, "`proon.delete()` object usage", tudor.equal, "`proon.object` is empty after the previous test", '[EMPTY]', function(proon) {
    return proon._objectSerializer();
  }, "Add a top-level leaf-node, `proon.add({ name:'a', content:'ok' })`", 'a ok', function(proon) {
    proon.add({
      name: 'a',
      content: 'ok'
    });
    return proon._objectSerializer();
  }, "Delete the top-level leaf-node, `proon.delete({ name:'a' })`", '[EMPTY]', function(proon) {
    proon["delete"]({
      name: 'a'
    });
    return proon._objectSerializer();
  }, "Add two second-level leaf-nodes", "a\na/b one\na/c two", function(proon) {
    proon.add({
      path: ['a'],
      name: 'b',
      content: 'one'
    }).add({
      path: ['a'],
      name: 'c',
      content: 'two'
    });
    return proon._objectSerializer();
  }, "Delete the first second-level leaf-node", "a\na/c two", function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'b'
    });
    return proon._objectSerializer();
  }, "Delete the second second-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'c'
    });
    return proon._objectSerializer();
  }, "Add a fifth-level leaf-node", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f deep!", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    });
    return proon._objectSerializer();
  }, "Delete the fifth-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return proon._objectSerializer();
  }, "Add a fifth-level leaf-node, and then insert a third-level leaf-node", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f deep!\na/b/c/g middle", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    });
    return proon._objectSerializer();
  }, "Delete the fifth-level leaf-node, but not the third-level leaf-node", "a\na/b\na/b/c\na/b/c/g middle", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return proon._objectSerializer();
  }, "Add a fifth-level leaf-node again", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f returned!\na/b/c/g middle", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'returned!'
    });
    return proon._objectSerializer();
  }, "Delete the third-level leaf-node, but not the fifth-level leaf-node", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f returned!", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c'],
      name: 'g'
    });
    return proon._objectSerializer();
  }, "Delete the second-level branch-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a', 'b']
    });
    return proon._objectSerializer();
  }, "Add fifth- and third-level leaf-nodes, and a sub-tree in the third-level", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f deep!\na/b/c/g middle\na/b/c/p\na/b/c/p/q\na/b/c/p/q/r side", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    }).add({
      path: ['a', 'b', 'c', 'p', 'q'],
      name: 'r',
      content: 'side'
    });
    return proon._objectSerializer();
  }, "Delete the fourth-level branch-node", "a\na/b\na/b/c\na/b/c/g middle\na/b/c/p\na/b/c/p/q\na/b/c/p/q/r side", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd']
    });
    return proon._objectSerializer();
  }, "Delete the 'q' branch-node", "a\na/b\na/b/c\na/b/c/g middle", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'p', 'q']
    });
    return proon._objectSerializer();
  }, "Add a second top-level branch-node", "a\na/b\na/b/c\na/b/c/g middle\nx\nx/y\nx/y/z another", function(proon) {
    proon.add({
      path: ['x', 'y'],
      name: 'z',
      content: 'another'
    });
    return proon._objectSerializer();
  }, "Delete everything, by specifying `path:[]`", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: []
    });
    return proon._objectSerializer();
  }, "`proon.delete()` object exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is undefined not object", function(proon) {
    return proon["delete"]();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is array not object", function(proon) {
    return proon["delete"]([]);
  }, "If set, `node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` is array not string", function(proon) {
    return proon["delete"]({
      name: []
    });
  }, "`node.name` must not be just a hyphen", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '-'
    });
  }, "`node.name` must not be just a digit", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '0'
    });
  }, "`node.name` must not be just a capital letter", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'A'
    });
  }, "`node.name` must not contain an underscore", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'fo_o'
    });
  }, "If set, `node.name` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'x' is undefined in the object", function(proon) {
    proon.add({
      name: 'c',
      path: ['a', 'b']
    });
    return proon["delete"]({
      name: 'x',
      path: ['a', 'b']
    });
  }, "If set, `node.name` must not refer to a branch-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'a' is an object branch- not leaf-node", function(proon) {
    return proon["delete"]({
      name: 'a'
    });
  }, "If set, `node.name` must not be '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '__',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path` is string not array", function(proon) {
    return proon["delete"]({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path.length` 100 > 99", function(proon) {
    return proon["delete"]({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain arrays", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is array not string", function(proon) {
    return proon.add({
      path: ['abc', ['def'], 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path`  must not contain '/'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd/ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      path: ['a', '__']
    });
  }, "If set, `node.path` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` 'x' is undefined in the object", function(proon) {
    return proon["delete"]({
      path: ['a', 'x'],
      name: 'c'
    });
  }, "If set, `node.path` must node refer to a leaf-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[2]` 'c' is an object leaf- not branch-node", function(proon) {
    return proon["delete"]({
      path: ['a', 'b', 'c']
    });
  }
]);

tudor.add([
  "03-2 Proon `delete()` storage", tudor.is, "(Set up a Proon instance with sessionStorage)", function() {
    var s;
    if (typeof window !== "undefined" && window !== null ? window.sessionStorage : void 0) {
      s = window.sessionStorage;
      s.clear();
    } else {
      s = {
        setItem: function(key, value) {
          this[key] = value;
          this.length++;
          return this.keys.push(key);
        },
        getItem: function(key) {
          return this[key] || null;
        },
        removeItem: function(key) {
          var i;
          i = this.keys.indexOf(key);
          if (-1 === i) {
            return;
          }
          this.keys.splice(i, 1);
          this.length--;
          return delete this[key];
        },
        clear: function() {
          var j, key, len, ref;
          ref = this.keys;
          for (j = 0, len = ref.length; j < len; j++) {
            key = ref[j];
            delete this[key];
          }
          this.length = 0;
          return this.keys = [];
        },
        key: function(i) {
          return this.keys[i];
        },
        length: 0,
        keys: []
      };
    }
    return [
      new Proon({
        storage: s
      })
    ];
  }, "`proon.delete()` works on storage without error", ªO, function(proon) {
    proon.storage.clear();
    proon.add({
      name: 'a'
    });
    return proon["delete"]({
      name: 'a'
    });
  }, "`proon.delete()` storage usage", tudor.equal, "`proon.storage` is empty after the previous test", '[EMPTY]', function(proon) {
    return storageSerializer(proon.storage);
  }, "Add a top-level leaf-node, `proon.add({ name:'a', content:'ok' })`", '/a -ok', function(proon) {
    proon.add({
      name: 'a',
      content: 'ok'
    });
    return storageSerializer(proon.storage);
  }, "Delete the top-level leaf-node, `proon.delete({ name:'a' })`", '[EMPTY]', function(proon) {
    proon["delete"]({
      name: 'a'
    });
    return storageSerializer(proon.storage);
  }, "Add two second-level leaf-nodes", "/a /\n/a/b -one\n/a/c -two", function(proon) {
    proon.add({
      path: ['a'],
      name: 'b',
      content: 'one'
    }).add({
      path: ['a'],
      name: 'c',
      content: 'two'
    });
    return storageSerializer(proon.storage);
  }, "Delete the first second-level leaf-node", "/a /\n/a/c -two", function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'b'
    });
    return storageSerializer(proon.storage);
  }, "Delete the second second-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'c'
    });
    return storageSerializer(proon.storage);
  }, "Add a fifth-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -deep!", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    });
    return storageSerializer(proon.storage);
  }, "Delete the fifth-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return storageSerializer(proon.storage);
  }, "Add a fifth-level leaf-node, and then insert a third-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -deep!\n/a/b/c/g -middle", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    });
    return storageSerializer(proon.storage);
  }, "Delete the fifth-level leaf-node, but not the third-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return storageSerializer(proon.storage);
  }, "Add a fifth-level leaf-node again", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -returned!\n/a/b/c/g -middle", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'returned!'
    });
    return storageSerializer(proon.storage);
  }, "Delete the third-level leaf-node, but not the fifth-level leaf-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -returned!", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c'],
      name: 'g'
    });
    return storageSerializer(proon.storage);
  }, "Spike storage with an unexpected item", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -returned!\noops How unexpected", function(proon) {
    proon.storage.setItem('oops', 'How unexpected');
    return storageSerializer(proon.storage);
  }, "Delete the second-level branch-node", 'oops How unexpected', function(proon) {
    proon["delete"]({
      path: ['a', 'b']
    });
    return storageSerializer(proon.storage);
  }, "Add fifth- and third-level leaf-nodes, and a sub-tree in the third-level", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/d /\n/a/b/c/d/e /\n/a/b/c/d/e/f -deep!\n/a/b/c/g -middle\n/a/b/c/p /\n/a/b/c/p/q /\n/a/b/c/p/q/r -side\noops How unexpected", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    }).add({
      path: ['a', 'b', 'c', 'p', 'q'],
      name: 'r',
      content: 'side'
    });
    return storageSerializer(proon.storage);
  }, "Delete the fourth-level branch-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle\n/a/b/c/p /\n/a/b/c/p/q /\n/a/b/c/p/q/r -side\noops How unexpected", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd']
    });
    return storageSerializer(proon.storage);
  }, "Delete the 'q' branch-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle\noops How unexpected", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'p', 'q']
    });
    return storageSerializer(proon.storage);
  }, "Add a second top-level branch-node", "/a /\n/a/b /\n/a/b/c /\n/a/b/c/g -middle\n/x /\n/x/y /\n/x/y/z -another\noops How unexpected", function(proon) {
    proon.add({
      path: ['x', 'y'],
      name: 'z',
      content: 'another'
    });
    return storageSerializer(proon.storage);
  }, "Delete everything, by specifying `path:[]`", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: []
    });
    return storageSerializer(proon.storage);
  }, "`proon.delete()` storage exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is undefined not object", function(proon) {
    return proon["delete"]();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is array not object", function(proon) {
    return proon["delete"]([]);
  }, "If set, `node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` is array not string", function(proon) {
    return proon["delete"]({
      name: []
    });
  }, "`node.name` must not be just a hyphen", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '-'
    });
  }, "`node.name` must not be just a digit", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '0'
    });
  }, "`node.name` must not be just a capital letter", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'A'
    });
  }, "`node.name` must not contain an underscore", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'fo_o'
    });
  }, "If set, `node.name` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'x' is undefined in storage", function(proon) {
    proon.add({
      name: 'c',
      path: ['a', 'b']
    });
    return proon["delete"]({
      name: 'x',
      path: ['a', 'b']
    });
  }, "If set, `node.name` must not refer to a branch-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'a' is a storage branch- not leaf-node", function(proon) {
    return proon["delete"]({
      name: 'a'
    });
  }, "If set, `node.name` must not be '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '__',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path` is string not array", function(proon) {
    return proon["delete"]({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path.length` 100 > 99", function(proon) {
    return proon["delete"]({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain arrays", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is array not string", function(proon) {
    return proon.add({
      path: ['abc', ['def'], 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path`  must not contain '/'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd/ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      path: ['a', '__']
    });
  }, "If set, `node.path` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` 'x' is undefined in storage", function(proon) {
    return proon["delete"]({
      path: ['a', 'x'],
      name: 'c'
    });
  }, "If set, `node.path` must node refer to a leaf-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[2]` 'c' is a storage leaf- not branch-node", function(proon) {
    return proon["delete"]({
      path: ['a', 'b', 'c']
    });
  }
]);

tudor.add([
  "03-3 Proon `delete()` fs", tudor.is, "(Set up a Proon instance with fs)", function() {
    var e, fs, fsMock;
    fsMock = {
      paths: {},
      readFileSync: function(path) {
        var err;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        if ('/' === this.paths[path]) {
          err = Error("EISDIR, illegal operation on a directory");
          err.code = 'EISDIR';
          throw err;
        }
        return this.paths[path];
      },
      writeFileSync: function(path, content) {
        return this.paths[path] = '-' + content;
      },
      mkdirSync: function(path) {
        var err, parent;
        if (this.paths[path]) {
          err = Error("EEXIST, file already exists '" + path + "'");
          err.code = 'EEXIST';
          throw err;
        }
        parent = path.replace(/\/[^\/]+$/, '');
        if (parent && '.' !== parent && !this.paths[parent]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        return this.paths[path] = '/';
      },
      unlinkSync: function(path) {
        var err;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        if ('/' === this.paths[path]) {
          err = Error("EPERM, operation not permitted '" + path + "'");
          err.code = 'EPERM';
          throw err;
        }
        return delete this.paths[path];
      },
      rmdirSync: function(path) {
        var content, err, l, p, ref;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        if ('/' !== this.paths[path]) {
          err = Error("ENOTDIR, not a directory '" + path + "'");
          err.code = 'ENOTDIR';
          throw err;
        }
        l = path.length;
        ref = this.paths;
        for (p in ref) {
          content = ref[p];
          if (p === path) {
            continue;
          }
          if (p.substr(0, l) === path) {
            err = Error("ENOTEMPTY, directory not empty '" + path + "'");
            err.code = 'ENOTEMPTY';
            throw err;
          }
        }
        delete this.paths[path];
        return void 0;
      },
      readdirSync: function(path) {
        var content, err, items, l, p, ref;
        if (path == null) {
          path = '';
        }
        if (path) {
          if (!this.paths[path]) {
            err = Error("ENOENT, no such file or directory '" + path + "'");
            err.code = 'ENOENT';
            throw err;
          }
          if ('/' !== this.paths[path]) {
            err = Error("ENOTDIR, not a directory '" + path + "'");
            err.code = 'ENOTDIR';
            throw err;
          }
        }
        items = [];
        l = path.length;
        ref = this.paths;
        for (p in ref) {
          content = ref[p];
          if (p === path) {
            continue;
          }
          if (p.substr(0, l) === path) {
            if (-1 === p.substr(l + 1).indexOf('/')) {
              items.push(p.substr(l + 1));
            }
          }
        }
        return items;
      },
      statSync: function(path) {
        var err, that;
        if (!this.paths[path]) {
          err = Error("ENOENT, no such file or directory '" + path + "'");
          err.code = 'ENOENT';
          throw err;
        }
        that = this;
        return {
          isFile: function() {
            return that.paths[path] && '/' !== that.paths[path];
          },
          isDirectory: function() {
            return that.paths[path] && '/' === that.paths[path];
          }
        };
      }
    };
    if (ªF !== typeof require) {
      fs = fsMock;
    } else {
      try {
        fs = require('fs');
      } catch (_error) {
        e = _error;
        fs = fsMock;
      }
    }
    try {
      fs.mkdirSync('./test');
    } catch (_error) {
      e = _error;
      if ('EEXIST' !== e.code) {
        throw e;
      }
    }
    fs.mkdirSync('./test/tmp');
    return [
      new Proon({
        fs: fs,
        pwd: './test/tmp'
      })
    ];
  }, "`proon.delete()` works on filesytem without error", ªO, function(proon) {
    proon._fsClear();
    proon.add({
      name: 'a'
    });
    return proon["delete"]({
      name: 'a'
    });
  }, "`proon.delete()` fs usage", tudor.equal, "`proon.fs` is empty after the previous test", '[EMPTY]', function(proon) {
    return proon._fsSerializer();
  }, "Add a top-level leaf-node, `proon.add({ name:'a', content:'ok' })`", 'a', function(proon) {
    proon.add({
      name: 'a',
      content: 'ok'
    });
    return proon._fsSerializer();
  }, "Delete the top-level leaf-node, `proon.delete({ name:'a' })`", '[EMPTY]', function(proon) {
    proon["delete"]({
      name: 'a'
    });
    return proon._fsSerializer();
  }, "Add two second-level leaf-nodes", "a\na/b\na/c", function(proon) {
    proon.add({
      path: ['a'],
      name: 'b',
      content: 'one'
    }).add({
      path: ['a'],
      name: 'c',
      content: 'two'
    });
    return proon._fsSerializer();
  }, "Delete the first second-level leaf-node", "a\na/c", function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'b'
    });
    return proon._fsSerializer();
  }, "Delete the second second-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a'],
      name: 'c'
    });
    return proon._fsSerializer();
  }, "Add a fifth-level leaf-node", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    });
    return proon._fsSerializer();
  }, "Delete the fifth-level leaf-node", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return proon._fsSerializer();
  }, "Add a fifth-level leaf-node, and then insert a third-level leaf-node", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f\na/b/c/g", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    });
    return proon._fsSerializer();
  }, "Delete the fifth-level leaf-node, but not the third-level leaf-node", "a\na/b\na/b/c\na/b/c/g", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f'
    });
    return proon._fsSerializer();
  }, "Add a fifth-level leaf-node again", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f\na/b/c/g", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'returned!'
    });
    return proon._fsSerializer();
  }, "Delete the third-level leaf-node, but not the fifth-level leaf-node", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c'],
      name: 'g'
    });
    return proon._fsSerializer();
  }, "Spike fs with an unexpected item", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f\noops", function(proon) {
    proon.fs.writeFileSync(proon.pwd + '/oops', 'How unexpected');
    return proon._fsSerializer();
  }, "Delete the second-level branch-node", 'oops', function(proon) {
    proon["delete"]({
      path: ['a', 'b']
    });
    return proon._fsSerializer();
  }, "Add fifth- and third-level leaf-nodes, and a sub-tree in the third-level", "a\na/b\na/b/c\na/b/c/d\na/b/c/d/e\na/b/c/d/e/f\na/b/c/g\na/b/c/p\na/b/c/p/q\na/b/c/p/q/r\noops", function(proon) {
    proon.add({
      path: ['a', 'b', 'c', 'd', 'e'],
      name: 'f',
      content: 'deep!'
    }).add({
      path: ['a', 'b', 'c'],
      name: 'g',
      content: 'middle'
    }).add({
      path: ['a', 'b', 'c', 'p', 'q'],
      name: 'r',
      content: 'side'
    });
    return proon._fsSerializer();
  }, "Delete the fourth-level branch-node", "a\na/b\na/b/c\na/b/c/g\na/b/c/p\na/b/c/p/q\na/b/c/p/q/r\noops", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'd']
    });
    return proon._fsSerializer();
  }, "Delete the 'q' branch-node", "a\na/b\na/b/c\na/b/c/g\noops", function(proon) {
    proon["delete"]({
      path: ['a', 'b', 'c', 'p', 'q']
    });
    return proon._fsSerializer();
  }, "Add a second top-level branch-node", "a\na/b\na/b/c\na/b/c/g\noops\nx\nx/y\nx/y/z", function(proon) {
    proon.add({
      path: ['x', 'y'],
      name: 'z',
      content: 'another'
    });
    return proon._fsSerializer();
  }, "Delete everything, by specifying `path:[]`", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: []
    });
    return proon._fsSerializer();
  }, "Delete everything when already empty", '[EMPTY]', function(proon) {
    proon["delete"]({
      path: []
    });
    return proon._fsSerializer();
  }, "`proon.delete()` fs exceptions", tudor["throw"], "The `node` argument is not optional", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is undefined not object", function(proon) {
    return proon["delete"]();
  }, "The `node` argument must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node` is array not object", function(proon) {
    return proon["delete"]([]);
  }, "If set, `node.name` must not be an array", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` is array not string", function(proon) {
    return proon["delete"]({
      name: []
    });
  }, "`node.name` must not be just a hyphen", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '-'
    });
  }, "`node.name` must not be just a digit", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '0'
    });
  }, "`node.name` must not be just a capital letter", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'A'
    });
  }, "`node.name` must not contain an underscore", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: 'fo_o'
    });
  }, "If set, `node.name` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'x' does not exist in filesystem", function(proon) {
    proon.add({
      name: 'c',
      path: ['a', 'b']
    });
    return proon["delete"]({
      name: 'x',
      path: ['a', 'b']
    });
  }, "If set, `node.name` must not refer to a branch-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` 'a' is a directory, not a file", function(proon) {
    return proon["delete"]({
      name: 'a'
    });
  }, "If set, `node.name` must not be '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.name` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      name: '__',
      path: ['a', 'b']
    });
  }, "If set, `node.path` must not be a string", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path` is string not array", function(proon) {
    return proon["delete"]({
      path: 'abc',
      name: 'foo'
    });
  }, "If set, `node.path` must not contain 100 or more levels", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path.length` 100 > 99", function(proon) {
    return proon["delete"]({
      path: Array(101).join('/a').split('/').slice(1),
      name: 'foo'
    });
  }, "If set, `node.path` must not contain arrays", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` is array not string", function(proon) {
    return proon.add({
      path: ['abc', ['def'], 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path`  must not contain '/'", "/proon/src/Proon.litcoffee Proon:add()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon.add({
      path: ['abc', 'd/ef', 'ghi'],
      name: 'foo'
    });
  }, "If set, `node.path` must not contain '__'", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` fails /^[a-z][-a-z0-9]{0,23}$/", function(proon) {
    return proon["delete"]({
      path: ['a', '__']
    });
  }, "If set, `node.path` must exist", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[1]` 'x' does not exist in filesystem", function(proon) {
    return proon["delete"]({
      path: ['a', 'x'],
      name: 'c'
    });
  }, "If set, `node.path` must node refer to a leaf-node", "/proon/src/Proon.litcoffee Proon:delete()\n  `node.path[2]` 'c' is a file, not a directory", function(proon) {
    return proon["delete"]({
      path: ['a', 'b', 'c']
    });
  }, "`proon.delete()` cleanup", tudor.equal, "`proon.filesytem` as expected before cleanup", "a\na/b\na/b/c", function(proon) {
    return proon._fsSerializer();
  }, "(Clean up filesystem)", void 0, function(proon) {
    proon.fs.unlinkSync(proon.pwd + '/a/b/c');
    proon.fs.rmdirSync(proon.pwd + '/a/b');
    proon.fs.rmdirSync(proon.pwd + '/a');
    return proon.fs.rmdirSync('./test/tmp');
  }
]);
}).call(this,this);
// Example vendor file. 
